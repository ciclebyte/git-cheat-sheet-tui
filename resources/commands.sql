PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE commands (
	id INTEGER NOT NULL, 
	title VARCHAR NOT NULL, 
	category VARCHAR NOT NULL, 
	command VARCHAR, 
	description VARCHAR, 
	content VARCHAR, 
	PRIMARY KEY (id)
);
INSERT INTO commands VALUES(1,'从现有的分支创建一个新的分支，并切换到新的分支','分支管理','git checkout -b <new_branch> <existing_branch>','`git checkout -b` 命令用于从现有的分支创建一个新的分支，并立即切换到新创建的分支。',replace('# 从现有的分支创建一个新的分支，并切换到新的分支\n\n## 一、命令介绍\n\n`git checkout -b` 命令用于从现有的分支创建一个新的分支，并立即切换到新创建的分支。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit checkout -b <new_branch> <existing_branch>\n```\n\n### 命令示例\n\n```bash\ngit checkout -b feature-branch main\n```\n\n## 三、输出说明\n\n执行该命令后，Git 会从指定的 `<existing_branch>` 分支创建一个新的分支 `<new_branch>`，并切换到该新分支。\n\n## 四、注意事项\n\n### 确认现有分支存在\n\n在执行该命令之前，请确保 `<existing_branch>` 存在，否则会提示错误。\n\n### 频繁切换分支的注意事项\n\n频繁切换分支可能会导致工作目录中的未提交更改丢失，建议在切换分支前保存或提交更改。','\n',char(10)));
INSERT INTO commands VALUES(2,'从现有的提交创建一个新的分支，并切换到新的分支','分支管理','git checkout <commit-hash> -b <new_branch_name>','`git checkout -b` 命令用于从现有的提交创建一个新的分支，并立即切换到该新分支。这个命令结合了 `git branch` 和 `git checkout` 两个命令的功能，既创建分支又切换分支。',replace('# 从现有的提交创建一个新的分支，并切换到新的分支\n\n## 一、命令介绍\n\n`git checkout -b` 命令用于从现有的提交创建一个新的分支，并立即切换到该新分支。这个命令结合了 `git branch` 和 `git checkout` 两个命令的功能，既创建分支又切换分支。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit checkout <commit-hash> -b <new_branch_name>\n```\n\n### 命令示例\n\n```bash\ngit checkout abc1234 -b feature-branch\n```\n\n## 三、输出说明\n\n执行该命令后，Git 会创建一个名为 `<new_branch_name>` 的新分支，并立即切换到该分支。如果命令成功执行，命令行会显示如下信息：\n\n```bash\nSwitched to a new branch ''feature-branch''\n```\n\n## 四、注意事项\n\n### 确认提交哈希\n\n在使用 `<commit-hash>` 之前，请确保该提交哈希是正确的，否则可能会导致创建了一个基于错误提交的分支。\n\n### 分支名称\n\n`<new_branch_name>` 应该是唯一的，并且遵循 Git 的分支命名规范。如果分支名称已经存在，Git 会提示错误信息，并且不会创建或切换分支。','\n',char(10)));
INSERT INTO commands VALUES(3,'切换分支','分支管理','git checkout <branch>','`git checkout` 命令用于切换当前工作目录到指定分支。通过此命令，你可以切换到已存在的本地分支或远程分支。',replace('# 切换分支\n\n## 一、命令介绍\n\n`git checkout` 命令用于切换当前工作目录到指定分支。通过此命令，你可以切换到已存在的本地分支或远程分支。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit checkout <branch>\n```\n\n### 命令示例\n\n```bash\ngit checkout main\n```\n\n## 三、输出说明(视情况修改省略)\n\n以下是一个常见的输出示例：\n\n```bash\nSwitched to branch ''main''\n```\n\n## 四、注意事项\n\n### 分支存在性\n\n在切换分支之前，请确保目标分支已存在。如果分支不存在，你可以先使用 `git branch` 命令创建分支。\n\n### 未提交的更改\n\n如果当前工作目录中有未提交的更改，`git checkout` 命令将拒绝切换分支，以防止数据丢失。可以使用 `git stash` 命令暂存更改，然后再切换分支。\n\n### 切换到远程分支\n\n如果要切换到远程分支，可以使用以下命令：\n\n```bash\ngit checkout -b <local-branch> origin/<remote-branch>\n```\n\n这将创建一个新的本地分支并切换到该分支，同时跟踪远程分支。','\n',char(10)));
INSERT INTO commands VALUES(4,'切换到之前的分支','分支管理','git checkout -','`git checkout -` 是一个快速切换分支的命令，它允许用户返回到之前所处的分支。这在需要频繁在两个分支之间切换的场景下非常有用。',replace('# 切换到之前的分支\n\n## 一、命令介绍\n\n`git checkout -` 是一个快速切换分支的命令，它允许用户返回到之前所处的分支。这在需要频繁在两个分支之间切换的场景下非常有用。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit checkout -\n```\n\n### 命令示例\n\n```bash\ngit checkout -\n```\n\n## 三、输出说明\n\n执行该命令后，Git 会切换到之前所处的分支，并输出切换成功的信息，例如：\n\n```bash\nSwitched to branch ''previous-branch''\n```\n\n## 四、注意事项\n\n### 1. 确保有之前的分支\n\n在执行 `git checkout -` 之前，确保你已经从另一个分支切换到当前分支，否则该命令将无法工作。\n\n### 2. 未提交的更改\n\n如果有未提交的更改，Git 会阻止切换分支。你可以选择提交更改、暂存更改或放弃更改后再执行该命令。\n\n### 3. 分支状态\n\n切换分支后，工作目录和暂存区的内容会更新为新分支的状态。确保在切换前保存好重要的更改。','\n',char(10)));
INSERT INTO commands VALUES(5,'列出所有的分支','分支管理','git branch -a','`git branch -a` 命令用于列出本地仓库中所有的分支，包括本地分支和远程跟踪分支。',replace('# 列出所有的分支\n\n## 一、命令介绍\n\n`git branch -a` 命令用于列出本地仓库中所有的分支，包括本地分支和远程跟踪分支。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit branch -a\n```\n\n### 命令示例\n\n```bash\ngit branch -a\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的分支信息及对应解释：\n\n```bash\n* main\n  feature-branch\n  remotes/origin/main\n  remotes/origin/feature-branch\n```\n\n- `* main`: 表示当前所在的分支是 `main` 分支。\n- `feature-branch`: 表示本地存在的 `feature-branch` 分支。\n- `remotes/origin/main`: 表示远程仓库 `origin` 中的 `main` 分支。\n- `remotes/origin/feature-branch`: 表示远程仓库 `origin` 中的 `feature-branch` 分支。\n\n## 四、注意事项\n\n### 1. 远程分支的更新\n\n`git branch -a` 列出的远程分支信息是基于上次与远程仓库同步时的状态。如果需要查看最新的远程分支信息，可以使用 `git fetch` 命令更新远程分支信息。\n\n### 2. 本地分支的同步\n\n`git branch -a` 不会自动同步本地分支与远程分支。如果需要更新本地分支以跟踪远程分支的变化，可以使用 `git checkout` 或 `git pull` 命令。','\n',char(10)));
INSERT INTO commands VALUES(6,'列出所有的本地分支','分支管理','git branch','`git branch` 命令用于列出、创建或删除本地分支。在不带任何选项或参数时，该命令会列出当前仓库中的所有本地分支。',replace('# 列出所有的本地分支\n\n## 一、命令介绍\n\n`git branch` 命令用于列出、创建或删除本地分支。在不带任何选项或参数时，该命令会列出当前仓库中的所有本地分支。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit branch\n```\n\n### 命令示例\n\n```bash\ngit branch\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的分支列表及对应解释：\n\n```bash\n  develop\n* main\n  feature-branch\n```\n\n- `develop`: 表示本地仓库中存在的 `develop` 分支。\n- `* main`: 表示当前检出的分支是 `main`，并且它是本地仓库中的 `main` 分支。\n- `feature-branch`: 表示本地仓库中存在的 `feature-branch` 分支。\n\n## 四、注意事项\n\n### 1. 仅列出本地分支\n\n`git branch` 命令默认仅列出本地分支。如果需要列出远程分支，可以使用 `git branch -r` 或 `git branch -a`。\n\n### 2. 当前分支标记\n\n当前检出的分支会以 `*` 标记。例如，`* main` 表示当前在 `main` 分支上。\n\n### 3. 详细信息\n\n如果需要查看每个分支的最后一次提交信息，可以使用 `git branch -v` 命令。','\n',char(10)));
INSERT INTO commands VALUES(7,'列出所有的远程分支','分支管理','git branch -r','`git branch -r` 命令用于列出本地仓库中所有的远程分支。这些分支是远程仓库中的分支在本地仓库中的引用。',replace('# 列出所有的远程分支\n\n## 一、命令介绍\n\n`git branch -r` 命令用于列出本地仓库中所有的远程分支。这些分支是远程仓库中的分支在本地仓库中的引用。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit branch -r\n```\n\n### 命令示例\n\n```bash\ngit branch -r\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的远程分支列表及对应解释：\n\n```bash\n  origin/feature-branch\n  origin/master\n  origin/develop\n```\n\n- `origin/feature-branch`: 远程仓库 `origin` 中的 `feature-branch` 分支。\n- `origin/master`: 远程仓库 `origin` 中的 `master` 分支。\n- `origin/develop`: 远程仓库 `origin` 中的 `develop` 分支。\n\n## 四、注意事项\n\n### 远程分支的同步\n\n执行 `git branch -r` 命令列出的远程分支是基于上一次 `git fetch` 或 `git pull` 操作的结果。如果远程仓库有新的分支或者分支有更新，需要先执行 `git fetch` 或 `git pull` 来同步最新的远程分支信息。\n\n### 分支名称的含义\n\n远程分支的名称通常以 `远程仓库名/分支名` 的格式显示，如 `origin/master`。这里的 `origin` 是远程仓库的默认名称，`master` 是分支名称。如果使用了其他远程仓库名称，分支名称会相应变化。','\n',char(10)));
INSERT INTO commands VALUES(8,'创建并切换到新分支','分支管理','git checkout -b <branch>','`git checkout -b <branch>` 命令用于创建一个新的分支并立即切换到该分支。这个命令结合了 `git branch` 和 `git checkout` 的功能，能够简化分支创建和切换的操作。',replace('# 创建并切换到新分支\n\n## 一、命令介绍\n\n`git checkout -b <branch>` 命令用于创建一个新的分支并立即切换到该分支。这个命令结合了 `git branch` 和 `git checkout` 的功能，能够简化分支创建和切换的操作。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit checkout -b <branch>\n```\n\n### 命令示例\n\n```bash\ngit checkout -b feature-login\n```\n\n## 三、输出说明\n\n执行该命令后，命令行会输出以下信息，表示成功创建并切换到新分支：\n\n```bash\nSwitched to a new branch ''feature-login''\n```\n\n## 四、注意事项\n\n### 分支名称\n\n`<branch>` 为新分支的名称，命名时应遵循项目的分支命名规范，通常使用小写字母和连字符（-）来分隔单词。\n\n### 分支冲突\n\n如果当前工作目录中存在未提交的更改，Git 会要求先提交或暂存这些更改，然后才能创建并切换到新分支。可以使用 `git stash` 命令暂存更改，或者在创建分支之前先提交更改。','\n',char(10)));
INSERT INTO commands VALUES(9,'删除本地分支','分支管理','git branch -d <branch>','`git branch -d` 命令用于删除指定的本地分支。该命令会检查要删除的分支是否已经完全合并到当前分支中，如果未完全合并，则会提示错误信息。',replace('# 删除本地分支\n\n## 一、命令介绍\n\n`git branch -d` 命令用于删除指定的本地分支。该命令会检查要删除的分支是否已经完全合并到当前分支中，如果未完全合并，则会提示错误信息。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit branch -d <branch>\n```\n\n### 命令示例\n\n```bash\ngit branch -d feature-branch\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的信息及对应解释：\n\n```bash\n# 如果分支已完全合并，输出如下：\nDeleted branch feature-branch (was abc1234).\n\n# 如果分支未完全合并，输出如下：\nerror: The branch ''feature-branch'' is not fully merged.\nIf you are sure you want to delete it, run ''git branch -D feature-branch''.\n```\n\n## 四、注意事项\n\n### 未合并分支的删除\n\n如果尝试删除的分支尚未完全合并到当前分支中，`git branch -d` 会拒绝删除操作并提示错误信息。如果确定要删除该分支，可以使用 `git branch -D` 强制删除。\n\n### 强制删除分支\n\n使用 `git branch -D <branch>` 可以强制删除本地分支，无论该分支是否已经合并。请谨慎使用此命令，以免丢失未合并的更改。\n\n```bash\ngit branch -D feature-branch\n```\n\n### 删除当前分支\n\n不能删除当前所在的分支。如果需要删除当前分支，必须先切换到其他分支。\n\n```bash\n# 切换到主分支\ngit checkout main\n\n# 删除目标分支\ngit branch -d feature-branch\n```','\n',char(10)));
INSERT INTO commands VALUES(10,'基于当前分支创建新分支','分支管理','git branch <new-branch>','`git branch <new-branch>` 命令用于基于当前分支创建一个新的分支。新分支将包含当前分支的所有提交记录，但不会切换到新分支。',replace('# 基于当前分支创建新分支\n\n## 一、命令介绍\n\n`git branch <new-branch>` 命令用于基于当前分支创建一个新的分支。新分支将包含当前分支的所有提交记录，但不会切换到新分支。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit branch <new-branch>\n```\n\n### 命令示例\n\n```bash\ngit branch feature-branch\n```\n\n## 三、输出说明\n\n执行该命令后，系统不会显示任何输出信息，但会在本地仓库中创建一个名为 `feature-branch` 的新分支。\n\n## 四、注意事项\n\n### 分支名称规范\n\n分支名称应遵循一定的命名规范，通常建议使用小写字母、数字和连字符（-）组合，避免使用特殊字符和空格。\n\n### 创建分支后切换\n\n创建新分支后，如果需要立即切换到该分支进行开发，可以使用 `git checkout <new-branch>` 或 `git switch <new-branch>` 命令。\n\n### 分支冲突\n\n如果仓库中已经存在同名的分支，系统将提示错误信息，并且不会创建重复的分支。','\n',char(10)));
INSERT INTO commands VALUES(11,'基于远程分支创建新的可追溯的分支','分支管理','git branch --track <new-branch> <remote-branch>','`git branch --track` 命令用于基于远程分支创建一个新的本地分支，并将本地分支与远程分支关联起来，以便在后续操作中能够自动跟踪远程分支的变化。',replace('# 基于远程分支创建新的可追溯的分支\n\n## 一、命令介绍\n\n`git branch --track` 命令用于基于远程分支创建一个新的本地分支，并将本地分支与远程分支关联起来，以便在后续操作中能够自动跟踪远程分支的变化。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit branch --track <new-branch> <remote-branch>\n```\n\n### 命令示例\n\n```bash\ngit branch --track feature-branch origin/feature-branch\n```\n\n## 三、输出说明\n\n该命令在执行后通常不会产生任何输出。如果命令执行成功，将创建一个新的本地分支 `feature-branch`，并将其与远程分支 `origin/feature-branch` 关联。\n\n## 四、注意事项\n\n### 确保远程分支存在\n\n在执行 `git branch --track` 命令之前，请确保指定的远程分支 `<remote-branch>` 确实存在于远程仓库中。如果远程分支不存在，命令将无法成功执行。\n\n### 本地分支名称冲突\n\n如果指定的新本地分支名称 `<new-branch>` 在本地已经存在，命令将无法创建新的分支，并会提示分支已存在。因此，在执行命令前，请确保本地仓库中没有与该名称相同的分支。','\n',char(10)));
INSERT INTO commands VALUES(12,'克隆远程仓库','创建','git clone [协议://][用户名@]主机名[:端口]/路径/到/仓库.git','`git clone` 命令用于从远程仓库克隆一个项目的副本到本地。该命令会将远程仓库的所有历史记录、分支和标签一并克隆到本地，方便开发者进行后续的开发工作。',replace('# 克隆远程仓库\n\n## 一、命令介绍\n\n`git clone` 命令用于从远程仓库克隆一个项目的副本到本地。该命令会将远程仓库的所有历史记录、分支和标签一并克隆到本地，方便开发者进行后续的开发工作。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit clone [协议://][用户名@]主机名[:端口]/路径/到/仓库.git\n```\n\n### 命令示例\n\n```bash\n# 通过 SSH 克隆远程仓库\ngit clone ssh://user@domain.com/repo.git\n\n# 通过 HTTP 克隆远程仓库\ngit clone http://domain.com/user/repo.git\n```\n\n## 三、输出说明(视情况修改省略)\n\n执行 `git clone` 命令后，终端会显示克隆过程的详细日志，包括下载对象、解压缩和检查文件等。克隆完成后，当前目录下会生成一个与远程仓库同名的新目录，其中包含项目的所有文件和 Git 元数据。\n\n```bash\nCloning into ''repo''...\nremote: Counting objects: 100, done.\nremote: Compressing objects: 100% (80/80), done.\nremote: Total 100 (delta 20), reused 0 (delta 0)\nReceiving objects: 100% (100/100), 1.23 MiB | 1.23 MiB/s, done.\nResolving deltas: 100% (20/20), done.\n```\n\n## 四、注意事项\n\n### 协议选择\n\n根据远程仓库的配置，可以选择不同的协议进行克隆。SSH 协议通常用于需要身份验证的私有仓库，而 HTTP 协议则适用于公开仓库。\n\n### 克隆深度\n\n如果需要克隆仓库的特定历史记录，可以使用 `--depth` 参数来指定克隆的深度。例如，`git clone --depth 1 http://domain.com/user/repo.git` 只会克隆最近的一次提交。\n\n### 克隆到指定目录\n\n可以通过在命令末尾指定目录名称，将仓库克隆到指定的目录中。例如，`git clone http://domain.com/user/repo.git myproject` 会将仓库克隆到 `myproject` 目录中。','\n',char(10)));
INSERT INTO commands VALUES(13,'在当前目录创建一个新的本地仓库','创建','git init','`git init` 命令用于在当前目录下初始化一个新的 Git 仓库。执行该命令后，Git 会在当前目录中创建一个名为 `.git` 的隐藏目录，该目录包含了 Git 用于跟踪版本控制的所有必要文件和子目录。',replace('# 在当前目录创建一个新的本地仓库\n\n## 一、命令介绍\n\n`git init` 命令用于在当前目录下初始化一个新的 Git 仓库。执行该命令后，Git 会在当前目录中创建一个名为 `.git` 的隐藏目录，该目录包含了 Git 用于跟踪版本控制的所有必要文件和子目录。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit init\n```\n\n### 命令示例\n\n```bash\ngit init\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的信息及对应解释：\n\n```bash\nInitialized empty Git repository in /path/to/your/repository/.git/\n```\n\n- `Initialized empty Git repository`：表示已成功初始化一个空的 Git 仓库。\n- `/path/to/your/repository/.git/`：表示新创建的 Git 仓库的路径。\n\n## 四、注意事项\n\n### 目录权限\n\n确保你对当前目录有写权限，否则 `git init` 命令将无法成功创建 `.git` 目录。\n\n### 现有仓库\n\n如果当前目录已经是一个 Git 仓库，再次执行 `git init` 命令将会重新初始化该仓库，但不会影响已有的 Git 历史记录或配置。','\n',char(10)));
INSERT INTO commands VALUES(14,'在指定目录创建一个新的本地仓库','创建','git init <directory>','`git init` 命令用于在指定目录中创建一个新的本地 Git 仓库。该命令会初始化一个空的 Git 仓库，并在该目录下生成一个名为 `.git` 的隐藏目录，该目录包含了 Git 仓库的所有必要元数据。',replace('# 在指定目录创建一个新的本地仓库\n\n## 一、命令介绍\n\n`git init` 命令用于在指定目录中创建一个新的本地 Git 仓库。该命令会初始化一个空的 Git 仓库，并在该目录下生成一个名为 `.git` 的隐藏目录，该目录包含了 Git 仓库的所有必要元数据。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit init <directory>\n```\n\n其中 `<directory>` 是你要创建 Git 仓库的目录路径。如果省略 `<directory>`，则会在当前目录下创建 Git 仓库。\n\n### 命令示例\n\n```bash\ngit init /path/to/your/repo\n```\n\n此命令将在 `/path/to/your/repo` 目录下创建一个新的 Git 仓库。\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的信息及对应解释：\n\n```bash\nInitialized empty Git repository in /path/to/your/repo/.git/\n```\n\n该输出表示 Git 仓库已在指定目录成功初始化，并且 `.git` 目录已被创建。\n\n## 四、注意事项\n\n### 目录权限\n\n确保你对指定的目录有写权限，否则 `git init` 命令将无法在该目录下创建 `.git` 目录。\n\n### 已有仓库\n\n如果指定的目录已经是一个 Git 仓库（即已经存在 `.git` 目录），`git init` 命令不会覆盖现有仓库，而是会输出如下信息：\n\n```bash\nReinitialized existing Git repository in /path/to/your/repo/.git/\n```\n\n### 空目录\n\n通常情况下，`git init` 会在指定的空目录或已包含文件的目录中创建一个新的 Git 仓库。但如果指定的目录已经是一个非空的 Git 仓库，`git init` 不会重新初始化该仓库。','\n',char(10)));
INSERT INTO commands VALUES(15,'使用配置好的 merge tool 解决冲突','合并与重置','git mergetool [<options>] [<file>…]','Git 是一款分布式版本控制软件。在 Git 中，当多个分支对同一个文件的同一个部分进行了不同的修改时，就会产生冲突。此时，用户需要手动解决冲突。为了简化冲突解决的流程，Git 提供了 `git mergetool` 命令，它可以调用用户配置的第三方合并工具（如 kdiff3、p4merge 等）来帮助解决冲突。',replace('# 配置自定义合并工具来解决冲突\n\n## 一、命令介绍\n\nGit 是一款分布式版本控制软件。在 Git 中，当多个分支对同一个文件的同一个部分进行了不同的修改时，就会产生冲突。此时，用户需要手动解决冲突。为了简化冲突解决的流程，Git 提供了 `git mergetool` 命令，它可以调用用户配置的第三方合并工具（如 kdiff3、p4merge 等）来帮助解决冲突。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit mergetool [<options>] [<file>…]\n```\n\n### 命令示例\n\n```bash\ngit mergetool\n```\n\n执行上述命令后，Git 会启动配置好的合并工具，打开所有存在冲突的文件，方便用户进行合并操作。\n\n## 三、输出说明\n\n执行 `git mergetool` 命令时，Git 会依次列出所有存在冲突的文件，并启动配置的合并工具来打开这些文件。用户在合并工具中完成冲突解决后，保存并退出。Git 会自动将合并后的结果标记为已解决冲突。\n\n```bash\nMerging:\nfile1.txt\nfile2.txt\n```\n\n例如，上述输出表示存在冲突的文件有 `file1.txt` 和 `file2.txt`。Git 会依次打开它们供用户进行合并。\n\n## 四、注意事项\n\n### 1. 配置合并工具\n\n在使用 `git mergetool` 之前，需要先配置好合并工具。可以通过以下命令配置：\n\n```bash\ngit config --global merge.tool <toolname>\n```\n\n其中，`<toolname>` 是合并工具的名称，如 `kdiff3`、`p4merge` 等。具体的工具名称和支持情况可以参考 Git 文档。\n\n### 2. 安全性检查\n\n在自动合并过程中，Git 会在修改文件前创建备份文件。默认情况下，当用户确认合并结果后，这些备份文件会被删除。如果需要保留备份文件，可以在执行 `git mergetool` 时加上 `--keep-backup` 选项。\n\n```bash\ngit mergetool --keep-backup\n```\n\n### 3. 配置工具参数\n\n某些合并工具可能需要特定参数才能正常工作。可以通过以下命令为特定工具配置参数：\n\n```bash\ngit config --global mergetool.<toolname>.cmd ''<command>''\n```\n\n其中，`<command>` 是启动合并工具时需要的完整命令行。通过这种方式，可以灵活地适配不同的合并工具。\n','\n',char(10)));
INSERT INTO commands VALUES(16,'列出合并的分支','合并与重置','git branch --merged [<commit>]','`git branch --merged` 命令用于列出当前分支中已经合并的所有分支。这可以帮助开发者识别哪些分支已经完成了合并工作，从而进行清理或删除。',replace('# 列出合并的分支\n\n## 一、命令介绍\n\n`git branch --merged` 命令用于列出当前分支中已经合并的所有分支。这可以帮助开发者识别哪些分支已经完成了合并工作，从而进行清理或删除。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit branch --merged [<commit>]\n```\n\n### 命令示例\n\n列出当前分支中已经合并的所有分支：\n\n```bash\ngit branch --merged\n```\n\n列出指定提交中已经合并的所有分支：\n\n```bash\ngit branch --merged <commit>\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的分支列表及对应解释：\n\n```bash\n# feature/login\n# feature/signup\n  master\n```\n\n解释：\n- `feature/login` 和 `feature/signup` 是已经合并到当前分支的分支。\n- `master` 是当前所在的分支。\n\n## 四、注意事项\n\n### 分支删除\n\n在确认分支已经合并且不再需要后，可以使用 `git branch -d <branch>` 命令删除这些分支。\n\n### 未合并分支\n\n如果需要列出未合并的分支，可以使用 `git branch --no-merged` 命令。','\n',char(10)));
INSERT INTO commands VALUES(17,'合并提交','合并与重置','git rebase -i <commit-just-before-first>','`git rebase -i` 是一个强大的 Git 命令，用于交互式地重新应用提交。通过该命令，你可以将多个提交合并为一个提交，从而简化提交历史。',replace('# 合并提交\n\n## 一、命令介绍\n\n`git rebase -i` 是一个强大的 Git 命令，用于交互式地重新应用提交。通过该命令，你可以将多个提交合并为一个提交，从而简化提交历史。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit rebase -i <commit-just-before-first>\n```\n\n### 命令示例\n\n假设你希望合并最近的三个提交，可以使用以下命令：\n\n```bash\ngit rebase -i HEAD~3\n```\n\n在执行该命令后，Git 会打开一个编辑器，列出最近的三个提交。你可以将 `pick` 替换为 `squash` 以合并提交。例如：\n\n```bash\npick <commit_id>\nsquash <commit_id2>\nsquash <commit_id3>\n```\n\n保存并关闭编辑器后，Git 会将这些提交合并为一个提交，并允许你编辑最终的提交信息。\n\n## 三、输出说明\n\n在执行 `git rebase -i` 命令后，Git 会打开一个交互式编辑器，显示最近的提交列表。你可以在此编辑器中修改提交的类型（如将 `pick` 替换为 `squash`），以达到合并提交的目的。\n\n## 四、注意事项\n\n### 注意提交顺序\n\n在交互式 rebase 中，提交的顺序是从上到下的。确保你正确地选择了要合并的提交，并按照正确的顺序进行修改。\n\n### 谨慎操作\n\n`git rebase -i` 会修改提交历史，因此在操作时要特别小心。建议在操作前备份当前分支，或者在操作完成后立即推送更改，以避免潜在的问题。','\n',char(10)));
INSERT INTO commands VALUES(18,'在编辑器中手动解决冲突后，将文件标记为已解决冲突','合并与重置',replace('git add <resolved-file>\ngit rm <resolved-file>','\n',char(10)),'在使用 Git 进行版本控制时，可能会遇到文件冲突的情况。在编辑器中手动解决冲突后，需要将这些文件标记为已解决冲突，以便继续进行合并操作。',replace('# 在编辑器中手动解决冲突后，将文件标记为已解决冲突\n\n## 一、命令介绍\n\n在使用 Git 进行版本控制时，可能会遇到文件冲突的情况。在编辑器中手动解决冲突后，需要将这些文件标记为已解决冲突，以便继续进行合并操作。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit add <resolved-file>\ngit rm <resolved-file>\n```\n\n### 命令示例\n\n```bash\ngit add myfile.txt\ngit rm conflictedfile.txt\n```\n\n## 三、注意事项\n\n### 确保冲突已解决\n\n在执行 `git add` 或 `git rm` 命令之前，请确保您已经完全解决了文件中的所有冲突。否则，合并操作可能会产生错误或未预期的结果。\n\n### 标记所有冲突文件\n\n如果您有多个文件冲突，请确保对每个冲突文件执行相应的 `git add` 或 `git rm` 命令，以便将它们全部标记为已解决。','\n',char(10)));
INSERT INTO commands VALUES(19,'将分支合并到当前 HEAD 中','合并与重置','git merge <branch>','`git merge` 命令用于将指定分支的更改合并到当前所在的分支（即 HEAD 指向的分支）中。该命令常用于在开发过程中，将一个分支的功能或修复合并到主分支或其他目标分支。',replace('# 将分支合并到当前 HEAD 中\n\n## 一、命令介绍\n\n`git merge` 命令用于将指定分支的更改合并到当前所在的分支（即 HEAD 指向的分支）中。该命令常用于在开发过程中，将一个分支的功能或修复合并到主分支或其他目标分支。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit merge <branch>\n```\n\n### 命令示例\n\n```bash\ngit merge feature-branch\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的信息及对应解释：\n\n```bash\n# 如果合并成功\nMerge made by the ''recursive'' strategy.\n file1.txt | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n# 如果发生冲突\nCONFLICT (content): Merge conflict in file1.txt\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n\n## 四、注意事项\n\n### 合并冲突\n\n如果在合并过程中发生冲突，Git 会中断合并操作并在冲突文件中标记出冲突的部分。此时需要手动解决冲突，并使用 `git add` 命令将解决后的文件标记为已解决，然后再使用 `git commit` 完成合并。\n\n### 合并策略\n\n`git merge` 默认使用递归策略进行合并。可以通过 `-s` 选项指定其他合并策略，例如 `-s octopus`（用于合并多个分支）或 `-s ours`（保留当前分支的更改）。','\n',char(10)));
INSERT INTO commands VALUES(20,'将合并工具全局配置为 meld（编辑器)','合并与重置','git config --global merge.tool meld','`git config --global merge.tool meld` 命令用于将 Git 的合并工具全局配置为 meld 编辑器。Meld 是一个可视化的差异和合并工具，适合用于解决合并冲突。通过此配置，用户在使用 Git 进行合并操作时，默认会使用 meld 编辑器来处理合并冲突。',replace('# 将合并工具全局配置为 meld（编辑器）\n\n## 一、命令介绍\n\n`git config --global merge.tool meld` 命令用于将 Git 的合并工具全局配置为 meld 编辑器。Meld 是一个可视化的差异和合并工具，适合用于解决合并冲突。通过此配置，用户在使用 Git 进行合并操作时，默认会使用 meld 编辑器来处理合并冲突。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit config --global merge.tool meld\n```\n\n### 命令示例\n\n```bash\ngit config --global merge.tool meld\n```\n\n## 三、输出说明(视情况修改省略)\n\n此命令执行后通常不会产生输出，而是直接在 Git 的全局配置文件中设置合并工具为 meld。\n\n## 四、注意事项\n\n### meld 编辑器需提前安装\n\n在使用此命令前，确保系统上已经安装了 meld 编辑器。如果未安装，此配置将无法生效。\n\n### 全局配置影响所有仓库\n\n由于使用了 `--global` 参数，此配置将应用于当前用户的所有 Git 仓库。如果希望仅为特定仓库设置合并工具，可以去掉 `--global` 参数并在特定仓库内执行命令。','\n',char(10)));
INSERT INTO commands VALUES(21,'将当前 HEAD 版本重置到分支中','合并与重置','git rebase <branch>','`git rebase` 命令用于将当前分支的提交记录重新应用到指定的分支上。它可以用来整理提交历史，将分支的提交记录转移到另一个分支的顶部。',replace('# 将当前 HEAD 版本重置到分支中\n\n## 一、命令介绍\n\n`git rebase` 命令用于将当前分支的提交记录重新应用到指定的分支上。它可以用来整理提交历史，将分支的提交记录转移到另一个分支的顶部。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit rebase <branch>\n```\n\n### 命令示例\n\n```bash\ngit rebase main\n```\n\n## 三、注意事项\n\n### 请勿重置已发布的提交\n\n在多人协作的仓库中，避免对已经推送到远程仓库的提交进行 `rebase` 操作，因为这会导致历史记录的变更，可能会对其他开发者的工作造成影响。\n\n### 合并冲突\n\n在执行 `rebase` 过程中，如果遇到冲突，Git 会暂停 `rebase` 过程并提示你解决冲突。解决冲突后，使用 `git rebase --continue` 继续 `rebase` 过程。\n\n### 中止 `rebase`\n\n如果你在 `rebase` 过程中遇到问题，可以使用以下命令中止 `rebase` 操作：\n\n```bash\ngit rebase --abort\n```\n\n### 交互式 `rebase`\n\n如果你想在 `rebase` 过程中对提交进行编辑、合并或删除等操作，可以使用交互式 `rebase`：\n\n```bash\ngit rebase -i <branch>\n```\n\n### 强制推送\n\n在 `rebase` 完成后，如果要将更改推送到远程仓库，可能需要使用 `--force` 或 `--force-with-lease` 选项，因为 `rebase` 会改变提交历史：\n\n```bash\ngit push --force-with-lease\n```','\n',char(10)));
INSERT INTO commands VALUES(22,'终止重置','合并与重置','git rebase --abort','`git rebase --abort` 命令用于终止当前的变基（rebase）操作，并将分支恢复到变基操作开始之前的状态。如果在变基过程中遇到冲突或其他问题，可以使用此命令中止变基并回退到初始状态。',replace('# 终止重置\n\n## 一、命令介绍\n\n`git rebase --abort` 命令用于终止当前的变基（rebase）操作，并将分支恢复到变基操作开始之前的状态。如果在变基过程中遇到冲突或其他问题，可以使用此命令中止变基并回退到初始状态。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit rebase --abort\n```\n\n### 命令示例\n\n```bash\ngit rebase --abort\n```\n\n## 三、输出说明(视情况修改省略)\n\n执行该命令后，通常不会有详细的输出信息，但会终止当前的变基操作，并将分支恢复到变基操作开始之前的状态。\n\n## 四、注意事项\n\n### 在变基过程中使用\n\n`git rebase --abort` 只能在变基过程中使用。在其他情况下执行此命令不会有任何效果。\n\n### 未提交的更改\n\n在执行 `git rebase --abort` 之前，建议确保所有未提交的更改已经保存或提交，以免丢失重要的修改。\n','\n',char(10)));
INSERT INTO commands VALUES(23,'解决冲突后继续重置','合并与重置','git rebase --continue','`git rebase --continue` 命令用于在解决冲突后继续执行 `git rebase` 操作。通常在 `git rebase` 过程中遇到冲突时，Git 会暂停 rebase 操作并提示用户手动解决冲突。解决冲突后，可以使用该命令继续完成 rebase 过程。',replace('# 解决冲突后继续重置\n\n## 一、命令介绍\n\n`git rebase --continue` 命令用于在解决冲突后继续执行 `git rebase` 操作。通常在 `git rebase` 过程中遇到冲突时，Git 会暂停 rebase 操作并提示用户手动解决冲突。解决冲突后，可以使用该命令继续完成 rebase 过程。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit rebase --continue\n```\n\n### 命令示例\n\n假设你在进行 `git rebase` 时遇到了冲突，并且已经手动解决了冲突并添加了修改后的文件，你可以运行以下命令继续 rebase 过程：\n\n```bash\ngit rebase --continue\n```\n\n## 三、注意事项\n\n### 冲突解决\n\n在执行 `git rebase --continue` 之前，确保所有冲突已经解决，并且已经使用 `git add` 命令将修改后的文件添加到暂存区。\n\n### 冲突标记\n\n在解决冲突时，Git 会在冲突文件中插入冲突标记（如 `<<<<<<<`、`=======`、`>>>>>>>`）。在继续 rebase 之前，务必删除这些标记并确保文件内容正确。\n\n### 多次冲突\n\n如果 rebase 过程中有多个提交导致冲突，你可能需要多次解决冲突并运行 `git rebase --continue` 命令来完成整个 rebase 过程。','\n',char(10)));
INSERT INTO commands VALUES(24,'从最新提交开始，显示所有的提交记录','提交历史','git log [options]','`git log` 命令用于显示当前分支的提交历史记录，默认从最新提交开始显示所有提交记录。该命令可以帮助开发者查看项目的提交历史、提交信息、作者、日期等详细信息。',replace('# 从最新提交开始，显示所有的提交记录\n\n## 一、命令介绍\n\n`git log` 命令用于显示当前分支的提交历史记录，默认从最新提交开始显示所有提交记录。该命令可以帮助开发者查看项目的提交历史、提交信息、作者、日期等详细信息。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit log [options]\n```\n\n### 命令示例\n\n```bash\ngit log\n```\n\n## 三、输出说明\n\n以下是执行 `git log` 命令后可能输出的提交记录及对应解释：\n\n```bash\ncommit a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0\nAuthor: John Doe <johndoe@example.com>\nDate:   Mon Jan 1 12:00:00 2023 +0000\n\n    Initial commit\n\n    This is the first commit message explaining the changes made in this commit.\n\ncommit b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0a1\nAuthor: Jane Smith <janesmith@example.com>\nDate:   Tue Jan 2 13:00:00 2023 +0000\n\n    Add new feature\n\n    This commit adds a new feature to the project.\n```\n\n- `commit`: 提交的唯一标识符（SHA-1 哈希值）。\n- `Author`: 提交的作者信息，包括姓名和电子邮件地址。\n- `Date`: 提交的日期和时间。\n- 提交信息：提交的详细描述信息。\n\n## 四、注意事项\n\n### 查看特定文件的提交历史\n\n如果只想查看某个文件的提交历史，可以使用以下命令：\n\n```bash\ngit log <file_name>\n```\n\n### 限制显示的提交数量\n\n如果只想查看最近几次的提交记录，可以使用 `-n` 选项来限制显示的提交数量。例如，以下命令只显示最近的 5 次提交：\n\n```bash\ngit log -n 5\n```\n\n### 显示提交的差异\n\n如果想要查看每次提交的差异内容，可以使用 `-p` 选项：\n\n```bash\ngit log -p\n```\n\n### 按作者过滤提交记录\n\n如果只想查看某个作者的提交记录，可以使用 `--author` 选项。例如，以下命令只显示作者名为 "John Doe" 的提交记录：\n\n```bash\ngit log --author="John Doe"\n```\n\n### 按日期范围过滤提交记录\n\n如果只想查看某个日期范围内的提交记录，可以使用 `--since` 和 `--until` 选项。例如，以下命令只显示 2023 年 1 月 1 日到 2023 年 1 月 31 日之间的提交记录：\n\n```bash\ngit log --since="2023-01-01" --until="2023-01-31"\n```','\n',char(10)));
INSERT INTO commands VALUES(25,'显示 reflog','提交历史','git reflog show [<ref>]','`git reflog` 命令用于显示本地仓库的引用日志（reflog）。引用日志记录了 HEAD 和分支的更新历史，包括提交、重置、合并等操作。即使某些提交不再被任何分支引用，仍然可以通过 reflog 查看这些提交的历史。',replace('# 显示 reflog\n\n## 一、命令介绍\n\n`git reflog` 命令用于显示本地仓库的引用日志（reflog）。引用日志记录了 HEAD 和分支的更新历史，包括提交、重置、合并等操作。即使某些提交不再被任何分支引用，仍然可以通过 reflog 查看这些提交的历史。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit reflog show [<ref>]\n```\n\n### 命令示例\n\n```bash\ngit reflog show\n```\n\n### 输出说明\n\n以下是执行该命令后可能输出的日志信息及对应解释：\n\n```bash\n# 示例输出\nabcd123 HEAD@{0}: commit: Update README file\nefgh456 HEAD@{1}: reset: moving to HEAD~1\nijkl789 HEAD@{2}: commit: Add new feature\n```\n\n- `abcd123`: 提交的哈希值。\n- `HEAD@{0}`: 引用的最新状态。\n- `commit: Update README file`: 操作类型及描述。\n\n## 四、注意事项\n\n### reflog 的有效期\n\n`git reflog` 记录的日志默认保留 90 天。过期后，日志条目将被自动删除。\n\n### 适用于本地仓库\n\n`git reflog` 仅适用于本地仓库，不会影响远程仓库的引用日志。','\n',char(10)));
INSERT INTO commands VALUES(26,'显示分支提交记录的差集','提交历史','git log --oneline <origin/master>..<remote/master> --left-right','该命令用于比较两个远程分支之间的提交记录差集。具体来说，它会显示`<remote/master>`分支中存在但`<origin/master>`分支中不存在的提交记录，并以单行的形式输出。',replace('# 显示分支提交记录的差集\n\n## 一、命令介绍\n\n该命令用于比较两个远程分支之间的提交记录差集。具体来说，它会显示`<remote/master>`分支中存在但`<origin/master>`分支中不存在的提交记录，并以单行的形式输出。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit log --oneline <origin/master>..<remote/master> --left-right\n```\n\n### 命令示例\n\n```bash\ngit log --oneline origin/master..remote/master --left-right\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的提交记录及对应解释：\n\n```bash\n# < 表示在 <origin/master> 分支中不存在的提交\n< commit_hash Commit message 1\n< commit_hash Commit message 2\n# > 表示在 <remote/master> 分支中不存在的提交\n> commit_hash Commit message 3\n> commit_hash Commit message 4\n```\n\n## 四、注意事项\n\n### 分支名称\n\n确保`<origin/master>`和`<remote/master>`分支名称正确无误。如果分支名称错误，可能会导致命令无法执行或输出不准确的结果。\n\n### 远程仓库\n\n在执行该命令之前，确保本地仓库已经连接到正确的远程仓库，并且已经获取了最新的远程分支信息。可以通过`git fetch`命令来更新远程分支信息。','\n',char(10)));
INSERT INTO commands VALUES(27,'显示所有提交','提交历史','git log --oneline','`git log --oneline` 命令用于显示当前分支的所有提交记录，每条记录仅显示提交的哈希值和提交信息。',replace('# 显示所有提交\n\n## 一、命令介绍\n\n`git log --oneline` 命令用于显示当前分支的所有提交记录，每条记录仅显示提交的哈希值和提交信息。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit log --oneline\n```\n\n### 命令示例\n\n```bash\ngit log --oneline\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的提交记录及对应解释：\n\n```bash\n# 提交记录的哈希值和提交信息\n1234567 Update README.md\nabcdefg Fix bug in main function\n```\n\n## 四、注意事项\n\n### 提交记录的显示顺序\n\n默认情况下，`git log` 命令会按提交时间的倒序显示提交记录，即最新的提交记录会显示在最前面。\n\n### 限制提交记录的显示数量\n\n可以通过增加 `-n` 参数来限制显示的提交记录数量，例如 `git log --oneline -n 5` 将仅显示最新的5条提交记录。','\n',char(10)));
INSERT INTO commands VALUES(28,'显示某个文件的所有修改','提交历史','git log -p <file>','`git log -p` 命令用于显示某个文件的所有修改记录。该命令会列出该文件在 Git 仓库中的每次提交，并显示每次提交的具体修改内容。',replace('# 显示某个文件的所有修改\n\n## 一、命令介绍\n\n`git log -p` 命令用于显示某个文件的所有修改记录。该命令会列出该文件在 Git 仓库中的每次提交，并显示每次提交的具体修改内容。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit log -p <file>\n```\n\n### 命令示例\n\n```bash\ngit log -p README.md\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的信息及对应解释：\n\n```bash\ncommit 1234567890abcdef1234567890abcdef12345678\nAuthor: John Doe <john.doe@example.com>\nDate:   Mon Jan 1 12:00:00 2023 +0000\n\n    Update README.md\n\ndiff --git a/README.md b/README.md\nindex abcdef0..1234567 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,5 +1,6 @@\n # Project Title\n-A brief description of the project.\n+A brief description of the project.\n+Added new features.\n\n ## Installation\n```\n\n- `commit`: 提交的哈希值。\n- `Author`: 提交的作者信息。\n- `Date`: 提交的日期和时间。\n- `diff --git`: 显示文件的修改内容，`a/README.md` 和 `b/README.md` 分别表示修改前和修改后的文件。\n- `@@ -1,5 +1,6 @@`: 显示修改的行号和内容，`-1,5` 表示修改前的内容在第1行到第5行，`+1,6` 表示修改后的内容在第1行到第6行。\n\n## 四、注意事项\n\n### 文件路径\n\n确保提供的 `<file>` 路径正确，否则命令将无法找到文件并显示错误信息。\n\n### 提交记录\n\n该命令仅显示与指定文件相关的提交记录，不显示其他文件的修改记录。','\n',char(10)));
INSERT INTO commands VALUES(29,'显示某个用户的所有提交','提交历史','git log --author="username"','`git log --author="username"` 命令用于显示指定用户的所有提交记录。通过指定 `--author` 参数，可以筛选出某个用户在 Git 仓库中所做的所有提交。',replace('# 显示某个用户的所有提交\n\n## 一、命令介绍\n\n`git log --author="username"` 命令用于显示指定用户的所有提交记录。通过指定 `--author` 参数，可以筛选出某个用户在 Git 仓库中所做的所有提交。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit log --author="username"\n```\n\n### 命令示例\n\n```bash\ngit log --author="john.doe"\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的提交记录信息及对应解释：\n\n```bash\ncommit 1a2b3c4d5e6f7g8h9i0j1k2l3m4n5o6p7q8r9s0t\nAuthor: john.doe <john.doe@example.com>\nDate:   Mon Oct 2 12:34:56 2023 +0000\n\n    Implement new feature XYZ\n\ncommit 2b3c4d5e6f7g8h9i0j1k2l3m4n5o6p7q8r9s0t1a\nAuthor: john.doe <john.doe@example.com>\nDate:   Sun Oct 1 10:11:12 2023 +0000\n\n    Fix bug in feature ABC\n```\n\n- `commit`：提交的哈希值，用于唯一标识该提交。\n- `Author`：提交的作者信息，包括用户名和邮箱。\n- `Date`：提交的日期和时间。\n- 提交信息：提交的详细描述。\n\n## 四、注意事项\n\n### 用户名匹配\n\n`--author` 参数匹配的是提交记录中的作者信息，因此需要确保输入的用户名与作者信息中的用户名完全一致，包括大小写。\n\n### 大小写敏感\n\n`--author` 参数默认是大小写敏感的，因此如果用户名的大小写不匹配，将无法筛选出对应的提交记录。如果需要忽略大小写进行匹配，可以使用 `--regexp-ignore-case` 参数。\n\n### 正则表达式\n\n`--author` 参数支持正则表达式，因此可以使用正则表达式来匹配更复杂的用户名模式。例如：\n\n```bash\ngit log --author="john.*"\n```','\n',char(10)));
INSERT INTO commands VALUES(30,'追踪文件修改','提交历史','git blame <file>','`git blame` 命令用于显示指定文件中每一行的最后修改信息，包括提交记录、作者信息以及修改时间。这对于跟踪代码中的改动以及确定谁在何时修改了某一行非常有帮助。',replace('# 追踪文件修改\n\n## 一、命令介绍\n\n`git blame` 命令用于显示指定文件中每一行的最后修改信息，包括提交记录、作者信息以及修改时间。这对于跟踪代码中的改动以及确定谁在何时修改了某一行非常有帮助。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit blame <file>\n```\n\n### 命令示例\n\n```bash\ngit blame README.md\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的信息及对应解释：\n\n```bash\n# abc1234 (John Doe 2023-10-01 14:30:00 +0800 1) # Project Title\n# def5678 (Jane Smith 2023-10-05 09:15:00 +0800 2) ## Introduction\n```\n\n- `abc1234` 是提交的哈希值，表示最后一次修改该行的提交记录。\n- `John Doe` 是修改该行的作者姓名。\n- `2023-10-01 14:30:00 +0800` 是修改该行的日期和时间。\n- `1` 是该行在文件中的行号。\n- `# Project Title` 是该行的内容。\n\n## 四、注意事项\n\n### 1. 文件路径\n\n确保文件路径正确，否则命令将无法找到指定文件。\n\n### 2. 文件类型\n\n`git blame` 适用于文本文件，对于二进制文件可能无法正确解析其内容。','\n',char(10)));
INSERT INTO commands VALUES(31,'从当前目录的所有文件中查找文本内容','搜索','git grep <pattern> [<pathspec>...]','',replace('# 从当前目录的所有文件中查找文本内容\n\n## 一、命令介绍   \n\n`git grep` 命令用于在 Git 仓库的所有文件中查找指定的文本内容。\n\n## 二、命令使用   \n\n### 命令格式\n\n```bash\ngit grep <pattern> [<pathspec>...]\n```\n\n### 命令示例\n\n```bash\ngit grep "Hello"\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的信息及对应解释：\n\n```bash\n# 文件路径:行号:匹配的文本内容\nexample.txt:1:Hello, World!\nREADME.md:10:Hello, this is a README file.\n```\n\n## 四、注意事项\n\n### 匹配模式\n\n`<pattern>` 支持正则表达式，可以更灵活地匹配文本内容。例如，可以使用 `git grep "Hello.*World"` 来查找以 "Hello" 开头并以 "World" 结尾的文本。\n\n### 指定搜索路径\n\n可以通过 `<pathspec>` 参数指定搜索的目录或文件。例如，使用 `git grep "Hello" src/` 仅在 `src` 目录下搜索。','\n',char(10)));
INSERT INTO commands VALUES(32,'在某一版本中搜索文本','搜索','git grep <search_string> <commit_or_branch>','`git grep` 命令用于在 Git 仓库中搜索指定的文本字符串。它可以在整个仓库中搜索，也可以限定在特定的版本或分支中进行搜索。通过指定版本号或分支名，你可以精确地在某个特定的提交或分支中查找文本。',replace('# 在某一版本中搜索文本\n\n## 一、命令介绍\n\n`git grep` 命令用于在 Git 仓库中搜索指定的文本字符串。它可以在整个仓库中搜索，也可以限定在特定的版本或分支中进行搜索。通过指定版本号或分支名，你可以精确地在某个特定的提交或分支中查找文本。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit grep <search_string> <commit_or_branch>\n```\n\n- `<search_string>`：要搜索的文本字符串。\n- `<commit_or_branch>`：限定搜索的版本号或分支名。\n\n### 命令示例\n\n```bash\ngit grep "Hello" v2.5\n```\n\n以上命令将在 `v2.5` 版本中搜索包含字符串 `"Hello"` 的文件。\n\n## 三、输出说明\n\n以下是执行该命令后可能的输出示例：\n\n```bash\npath/to/file1.txt:Hello, World!\npath/to/file2.java:// Hello, this is a comment\n```\n\n- `path/to/file1.txt:Hello, World!`：表示在 `file1.txt` 文件中找到了 `"Hello, World!"` 这一行文本。\n- `path/to/file2.java:// Hello, this is a comment`：表示在 `file2.java` 文件中找到了 `"Hello, this is a comment"` 这一行注释。\n\n## 四、注意事项\n\n### 搜索范围\n\n`git grep` 命令默认在当前工作目录下搜索，但可以通过指定版本号或分支名来限定搜索范围。如果不指定版本号或分支名，则会在当前工作树的文件中搜索。\n\n### 大小写敏感\n\n`git grep` 默认是大小写敏感的。如果需要忽略大小写，可以使用 `-i` 选项：\n\n```bash\ngit grep -i "hello" v2.5\n```\n\n### 正则表达式\n\n`git grep` 支持正则表达式搜索。如果需要使用正则表达式，可以使用 `-E` 选项：\n\n```bash\ngit grep -E "Hello|Hi" v2.5\n```\n\n### 递归搜索\n\n`git grep` 默认会递归搜索子目录中的所有文件。如果需要禁用递归搜索，可以使用 `--no-recursive` 选项：\n\n```bash\ngit grep --no-recursive "Hello" v2.5\n```','\n',char(10)));
INSERT INTO commands VALUES(33,'显示引入了特定关键字的提交','搜索','git log -S ''keyword''','`git log -S ''keyword''` 命令用于显示在提交历史中引入了特定关键字的提交。该命令会搜索整个提交历史，找出那些在代码中新增或删除了指定关键字的提交。',replace('# 显示引入了特定关键字的提交\n\n## 一、命令介绍\n\n`git log -S ''keyword''` 命令用于显示在提交历史中引入了特定关键字的提交。该命令会搜索整个提交历史，找出那些在代码中新增或删除了指定关键字的提交。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit log -S ''keyword''\n```\n\n### 命令示例\n\n```bash\ngit log -S ''TODO''\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的提交信息及对应解释：\n\n```bash\ncommit 3a9b9c5d1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d\nAuthor: John Doe <johndoe@example.com>\nDate:   Mon Jan 1 12:00:00 2023 +0000\n\n    Added new TODO items\n\ncommit 1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\nAuthor: Jane Doe <janedoe@example.com>\nDate:   Sun Dec 31 12:00:00 2022 +0000\n\n    Removed outdated TODO items\n```\n\n## 四、注意事项\n\n### 关键字区分大小写\n\n`git log -S` 命令对关键字是区分大小写的。如果要进行不区分大小写的搜索，可以使用 `-i` 选项，如 `git log -Si ''keyword''`。\n\n### 关键字可以是正则表达式\n\n`git log -S` 命令还支持使用正则表达式进行搜索。例如，`git log -S ''TODO|FIXME''` 可以用来搜索包含 `TODO` 或 `FIXME` 的提交。\n\n### 结合其他选项使用\n\n`git log -S` 命令可以与其他 `git log` 选项结合使用，以进一步过滤输出。例如，`git log -S ''keyword'' --oneline` 可以以简洁的单行格式显示提交信息。','\n',char(10)));
INSERT INTO commands VALUES(34,'显示引入了特定关键字的提交（使用正则表达式）','搜索','git log -S ''keyword'' --pickaxe-regex','`git log -S ''keyword'' --pickaxe-regex` 命令用于显示在提交中引入了特定关键字的提交记录。通过使用正则表达式，可以更灵活地匹配关键字。',replace('# 显示引入了特定关键字的提交（使用正则表达式）\n\n## 一、命令介绍\n\n`git log -S ''keyword'' --pickaxe-regex` 命令用于显示在提交中引入了特定关键字的提交记录。通过使用正则表达式，可以更灵活地匹配关键字。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit log -S ''keyword'' --pickaxe-regex\n```\n\n### 命令示例\n\n```bash\ngit log -S ''bugfix'' --pickaxe-regex\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的提交信息及对应解释：\n\n```bash\ncommit 1234567890abcdef1234567890abcdef12345678\nAuthor: John Doe <john.doe@example.com>\nDate:   Mon Oct 10 10:00:00 2022 +0000\n\n    Fix bug causing application crash\n\ncommit abcdef1234567890abcdef1234567890abcdef12\nAuthor: Jane Smith <jane.smith@example.com>\nDate:   Sun Oct 9 09:00:00 2022 +0000\n\n    Add new feature to improve performance\n```\n\n## 四、注意事项\n\n### 正则表达式使用\n\n在使用正则表达式时，确保表达式的正确性，以避免匹配到不相关的内容。\n\n### 关键字匹配\n\n该命令只会匹配在提交中引入的关键字，而不会匹配删除或修改的关键字。','\n',char(10)));
INSERT INTO commands VALUES(35,'删除添加 .gitignore 文件前错误提交的文件','撤销','git rm -r --cached .','`git rm -r --cached .` 命令用于从 Git 仓库的索引中移除所有已跟踪的文件，但不会删除工作目录中的实际文件。这在添加 `.gitignore` 文件后，需要删除之前错误提交的文件时非常有用。',replace('# 删除添加 .gitignore 文件前错误提交的文件\n\n## 一、命令介绍\n\n`git rm -r --cached .` 命令用于从 Git 仓库的索引中移除所有已跟踪的文件，但不会删除工作目录中的实际文件。这在添加 `.gitignore` 文件后，需要删除之前错误提交的文件时非常有用。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit rm -r --cached .\n```\n\n### 命令示例\n\n```bash\ngit rm -r --cached .\n```\n\n在上述示例中，`.` 表示当前目录及其所有子目录中的文件都会被移除索引。\n\n## 三、注意事项\n\n### 1. 不会删除工作目录文件\n\n使用 `--cached` 选项后，Git 只会从索引中移除文件，而不会删除工作目录中的实际文件。这确保了你的工作文件不会意外被删除。\n\n### 2. 重新添加文件到索引\n\n执行该命令后，你需要重新添加文件到索引。通常的做法是执行 `git add .` 命令，以便根据 `.gitignore` 文件的规则重新添加文件。\n\n### 3. 确保 `.gitignore` 文件已配置\n\n在执行该命令之前，确保 `.gitignore` 文件已经正确配置，以避免再次错误提交不需要的文件。\n\n### 4. 谨慎使用\n\n该命令会影响所有已跟踪的文件，因此在执行前务必确认你是否确实需要移除索引中的所有文件。','\n',char(10)));
INSERT INTO commands VALUES(36,'将 HEAD 重置到上一次提交的版本，并保留未提交的本地修改','撤销','git reset --keep <commit>','`git reset --keep <commit>` 命令用于将 `HEAD` 指针重置到指定的提交版本，同时保留工作目录中未提交的本地修改。这个命令通常用于回退到之前的某个提交状态，但保留当前工作目录中的更改。',replace('# 将 HEAD 重置到上一次提交的版本，并保留未提交的本地修改\n\n## 一、命令介绍\n\n`git reset --keep <commit>` 命令用于将 `HEAD` 指针重置到指定的提交版本，同时保留工作目录中未提交的本地修改。这个命令通常用于回退到之前的某个提交状态，但保留当前工作目录中的更改。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit reset --keep <commit>\n```\n\n### 命令示例\n\n```bash\ngit reset --keep HEAD^\n```\n\n## 三、输出说明\n\n执行该命令后，Git 会将 `HEAD` 指针重置到指定的提交版本，并且不会删除工作目录中的未提交更改。此命令不会生成额外的输出信息，除非在执行过程中出现错误。\n\n## 四、注意事项\n\n### 谨慎使用\n\n`git reset --keep` 是一个强大的命令，它会改变 `HEAD` 指针的位置。请确保在执行此命令之前，您已经理解了它的作用，并且已经备份了重要的更改。\n\n### 保留未提交的修改\n\n`--keep` 选项会保留工作目录中的未提交修改，但在重置过程中，如果这些修改与目标提交版本中的文件内容冲突，Git 将拒绝执行操作。因此，在执行此命令前，请确保未提交的修改与目标提交版本兼容。','\n',char(10)));
INSERT INTO commands VALUES(37,'将 HEAD 重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区','撤销','git reset <commit>','该命令用于将当前分支的 HEAD 指针重置到指定的提交，并将该提交之后的所有修改标记为未添加到缓存区的状态。这样可以撤销最近的提交，同时保留工作目录中的更改。',replace('# 将 HEAD 重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区\n\n## 一、命令介绍\n\n该命令用于将当前分支的 HEAD 指针重置到指定的提交，并将该提交之后的所有修改标记为未添加到缓存区的状态。这样可以撤销最近的提交，同时保留工作目录中的更改。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit reset <commit>\n```\n\n### 命令示例\n\n```bash\ngit reset HEAD~\n```\n\n## 三、输出说明\n\n执行该命令后，通常不会有详细的输出信息，但可以通过 `git status` 查看工作目录和缓存区的状态变化。\n\n## 四、注意事项\n\n### 1. 重置操作的影响\n\n该操作会将 HEAD 指针移动到指定的提交，并且会将该提交之后的所有修改标记为未添加到缓存区。这意味着这些更改仍然存在于工作目录中，但需要重新添加到缓存区才能进行下一次提交。\n\n### 2. 数据丢失风险\n\n如果指定的提交之后有未提交的更改，这些更改将会被保留在工作目录中。然而，如果工作目录中的更改被覆盖或删除，这些更改将无法恢复。因此，在执行该命令前，请确保已经备份了重要的更改。\n\n### 3. 使用场景\n\n该命令常用于撤销上一次提交，同时保留工作目录中的更改，以便重新修改后再次提交。','\n',char(10)));
INSERT INTO commands VALUES(38,'将 HEAD 重置到指定的版本，并放弃该版本之后的所有修改','撤销','git reset --hard <commit>','`git reset --hard` 命令用于将当前分支的 HEAD 指针重置到指定的提交（commit），并且会放弃该提交之后的所有修改。这个操作会强制将工作目录和暂存区的内容恢复到指定提交的状态。',replace('# 将 HEAD 重置到指定的版本，并放弃该版本之后的所有修改\n\n## 一、命令介绍\n\n`git reset --hard` 命令用于将当前分支的 HEAD 指针重置到指定的提交（commit），并且会放弃该提交之后的所有修改。这个操作会强制将工作目录和暂存区的内容恢复到指定提交的状态。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit reset --hard <commit>\n```\n\n### 命令示例\n\n```bash\ngit reset --hard HEAD~1\n```\n\n上述命令将当前分支的 HEAD 指针重置到上一个提交，并且放弃该提交之后的所有修改。\n\n## 三、输出说明\n\n执行该命令后，Git 会输出一条消息，指示 HEAD 指针已经重置到指定的提交。例如：\n\n```bash\nHEAD is now at <commit_hash> <commit_message>\n```\n\n其中 `<commit_hash>` 是指定提交的哈希值，`<commit_message>` 是该提交的消息。\n\n## 四、注意事项\n\n### 数据丢失风险\n\n使用 `git reset --hard` 命令会丢弃工作目录和暂存区中未提交的更改，这些更改将无法恢复。因此，在执行此命令之前，请确保你已经备份了所有重要更改。\n\n### 不可逆操作\n\n`git reset --hard` 是一个不可逆的操作，一旦执行，之前未提交的更改将永久丢失。建议在执行此操作前，使用 `git stash` 或 `git commit` 来保存当前的修改。\n\n### 谨慎使用\n\n在协同开发环境中，使用 `git reset --hard` 可能会导致远程仓库的历史记录与本地不同步，进而影响其他开发者的工作。如果需要修改远程仓库的历史记录，建议使用 `git revert` 或 `git rebase` 等更安全的方法。','\n',char(10)));
INSERT INTO commands VALUES(39,'放弃工作目录下的所有修改','撤销','git checkout HEAD <file>','`git checkout HEAD <file>` 命令用于放弃工作目录中对指定文件的所有修改，将其恢复到最近一次提交的状态。这个命令可以有效地撤销对文件的未提交更改，确保工作目录中的文件与仓库中的最新版本一致。',replace('# 放弃工作目录下的所有修改\n\n## 一、命令介绍\n\n`git checkout HEAD <file>` 命令用于放弃工作目录中对指定文件的所有修改，将其恢复到最近一次提交的状态。这个命令可以有效地撤销对文件的未提交更改，确保工作目录中的文件与仓库中的最新版本一致。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit checkout HEAD <file>\n```\n\n### 命令示例\n\n```bash\ngit checkout HEAD example.txt\n```\n\n## 三、输出说明\n\n执行该命令后，如果成功，不会有任何输出。如果文件不存在或路径错误，Git 会返回相应的错误信息。\n\n## 四、注意事项\n\n### 文件路径\n\n确保 `<file>` 参数指定的文件路径正确，否则 Git 将无法找到该文件并返回错误。\n\n### 未提交的更改\n\n使用该命令会永久放弃工作目录中对指定文件的所有未提交更改，因此在执行前请确保这些更改确实不需要保留。\n\n### 影响范围\n\n该命令仅影响指定的文件，不会影响其他文件或整个工作目录的状态。如果需要放弃所有文件的修改，可以使用 `git reset --hard` 命令。','\n',char(10)));
INSERT INTO commands VALUES(40,'用远程分支强制覆盖本地分支','撤销','git reset --hard <remote/branch>','`git reset --hard` 命令用于将当前分支的 HEAD、索引和工作目录强制重置为指定的提交状态。结合远程分支的使用，可以用来强制覆盖本地分支的内容，使其与远程分支完全一致。',replace('# 用远程分支强制覆盖本地分支\n\n## 一、命令介绍\n\n`git reset --hard` 命令用于将当前分支的 HEAD、索引和工作目录强制重置为指定的提交状态。结合远程分支的使用，可以用来强制覆盖本地分支的内容，使其与远程分支完全一致。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit reset --hard <remote/branch>\n```\n\n### 命令示例\n\n```bash\ngit reset --hard origin/my-feature\n```\n\n## 三、输出说明\n\n执行该命令后，Git 会输出以下信息，提示本地分支已被重置为远程分支的状态：\n\n```bash\nHEAD is now at <commit-hash> <commit-message>\n```\n\n## 四、注意事项\n\n### 数据丢失风险\n\n使用 `git reset --hard` 命令会强制覆盖本地分支的内容，所有未提交的更改和本地工作目录中的文件将被永久删除。请确保在执行此命令前已经备份或提交了所有重要更改。\n\n### 确保远程分支存在\n\n在运行此命令前，请确保指定的远程分支确实存在，并且已经正确配置了远程仓库。否则，命令将无法找到指定的远程分支并导致错误。','\n',char(10)));
INSERT INTO commands VALUES(41,'重置一个提交','撤销','git revert <commit>','`git revert` 命令用于撤销一个或多个提交的更改。与 `git reset` 不同，`git revert` 不会删除历史记录，而是通过创建一个新的提交来撤销指定提交的更改。这种方式更安全，尤其是在团队协作中，因为它不会影响其他开发者的工作。',replace('# 重置一个提交\n\n## 一、命令介绍\n\n`git revert` 命令用于撤销一个或多个提交的更改。与 `git reset` 不同，`git revert` 不会删除历史记录，而是通过创建一个新的提交来撤销指定提交的更改。这种方式更安全，尤其是在团队协作中，因为它不会影响其他开发者的工作。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit revert <commit>\n```\n\n### 命令示例\n\n```bash\ngit revert abc1234\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的信息：\n\n```bash\n[master abc5678] Revert "Original commit message"\n 1 file changed, 1 insertion(+), 1 deletion(-)\n```\n\n输出信息表明一个新的提交已经创建，该提交撤销了指定提交的更改。\n\n## 四、注意事项\n\n### 提交哈希必须有效\n\n`<commit>` 必须是一个有效的提交哈希。你可以使用 `git log` 查看提交历史并找到正确的提交哈希。\n\n### 解决冲突\n\n如果在执行 `git revert` 时遇到冲突，Git 会提示你手动解决冲突。解决冲突后，使用 `git add` 标记冲突已解决，然后使用 `git revert --continue` 继续完成撤销操作。\n\n### 撤销多个提交\n\n如果需要撤销多个提交，可以指定多个提交哈希，或者使用提交范围。例如：\n\n```bash\ngit revert abc1234 def5678\n```\n\n或者\n\n```bash\ngit revert abc1234..def5678\n```','\n',char(10)));
INSERT INTO commands VALUES(42,'从远程仓库下载所有修改，但不合并到 HEAD 中','更新与发布','git fetch <remote>','`git fetch` 命令用于从远程仓库下载所有修改，但不会自动将这些修改合并到当前分支的 HEAD 中。这个命令通常用于查看远程仓库的更新情况，而不会直接影响本地的工作分支。',replace('# 从远程仓库下载所有修改，但不合并到 HEAD 中\n\n## 一、命令介绍\n\n`git fetch` 命令用于从远程仓库下载所有修改，但不会自动将这些修改合并到当前分支的 HEAD 中。这个命令通常用于查看远程仓库的更新情况，而不会直接影响本地的工作分支。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit fetch <remote>\n```\n\n### 命令示例\n\n```bash\ngit fetch origin\n```\n\n## 三、输出说明\n\n以下是执行 `git fetch` 命令后可能输出的信息及解释：\n\n```bash\nFrom https://github.com/user/repo\n * [new branch]      feature-branch -> origin/feature-branch\n```\n\n- `From https://github.com/user/repo` 表示远程仓库的 URL。\n- `* [new branch] feature-branch -> origin/feature-branch` 表示远程仓库中有新的分支 `feature-branch`，并且它被下载到本地的 `origin/feature-branch` 引用中。\n\n## 四、注意事项\n\n### 远程仓库名称\n\n在执行 `git fetch` 命令时，需要指定远程仓库的名称（如 `origin`）。如果未指定远程仓库名称，默认会从所有远程仓库下载修改。\n\n### 不自动合并\n\n`git fetch` 命令不会自动将下载的修改合并到当前分支的 HEAD 中。如果需要将这些修改合并到当前分支，可以使用 `git merge` 或 `git rebase` 命令。','\n',char(10)));
INSERT INTO commands VALUES(43,'从远程仓库下载所有修改，并自动与 HEAD 合并','更新与发布','git pull <remote> <branch>','`git pull` 命令用于从远程仓库下载所有修改，并自动与当前分支的 HEAD 进行合并。这个命令相当于先执行 `git fetch` 获取远程仓库的更新，然后再执行 `git merge` 将这些更新合并到当前分支。',replace('# 从远程仓库下载所有修改，并自动与 HEAD 合并\n\n## 一、命令介绍\n\n`git pull` 命令用于从远程仓库下载所有修改，并自动与当前分支的 HEAD 进行合并。这个命令相当于先执行 `git fetch` 获取远程仓库的更新，然后再执行 `git merge` 将这些更新合并到当前分支。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit pull <remote> <branch>\n```\n\n- `<remote>`：指定远程仓库的名称，通常为 `origin`。\n- `<branch>`：指定要拉取的分支名称。\n\n### 命令示例\n\n```bash\ngit pull origin main\n```\n\n这个示例命令会从名为 `origin` 的远程仓库的 `main` 分支拉取所有修改，并自动将这些修改合并到当前分支的 HEAD。\n\n## 三、输出说明\n\n以下是执行 `git pull` 命令后可能输出的信息及对应解释：\n\n```bash\n# 远程仓库的更新信息\nremote: Counting objects: 3, done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (3/3), done.\n\n# 本地分支的合并信息\nUpdating 1ae224e..3f2b8e1\nFast-forward\n README.md | 2 ++\n 1 file changed, 2 insertions(+)\n```\n\n- `remote:` 开头的行显示了从远程仓库获取的更新信息，包括对象计数、压缩和解包的过程。\n- `Updating` 开头的行显示了本地分支的更新信息，包括提交哈希值的变动和文件的修改情况。\n\n## 四、注意事项\n\n### 合并冲突\n\n如果远程仓库的修改与本地分支的修改存在冲突，`git pull` 会自动触发合并冲突。此时需要手动解决冲突，然后提交合并结果。\n\n### 自动合并\n\n默认情况下，`git pull` 会自动执行合并操作。如果希望避免自动合并，可以使用 `--rebase` 选项来进行变基操作：\n\n```bash\ngit pull --rebase origin main\n```\n\n这个命令会在拉取远程修改后，将本地修改应用到远程修改之上，而不是直接合并。','\n',char(10)));
INSERT INTO commands VALUES(44,'以 rebase 方式将远程分支与本地合并','更新与发布','git pull --rebase <remote> <branch>','`git pull --rebase` 命令用于将远程分支的更改以 rebase 的方式合并到本地分支。与普通的 `git pull` 不同，`git pull --rebase` 会将本地的提交“基变”到远程分支的最新提交之上，从而保持提交历史的线性。',replace('# 以 rebase 方式将远程分支与本地合并\n\n## 一、命令介绍\n\n`git pull --rebase` 命令用于将远程分支的更改以 rebase 的方式合并到本地分支。与普通的 `git pull` 不同，`git pull --rebase` 会将本地的提交“基变”到远程分支的最新提交之上，从而保持提交历史的线性。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit pull --rebase <remote> <branch>\n```\n\n### 命令示例\n\n```bash\ngit pull --rebase origin main\n```\n\n## 三、输出说明\n\n执行该命令后，Git 会将远程分支 `main` 的更改拉取到本地，并将本地的提交依次应用到这些更改之上。如果存在冲突，Git 会暂停 rebase 过程并提示你解决冲突。解决冲突后，可以使用 `git rebase --continue` 继续 rebase 过程。\n\n## 四、注意事项\n\n### 冲突处理\n\n在执行 `git pull --rebase` 时，如果遇到冲突，Git 会暂停 rebase 过程并提示你解决冲突。解决冲突后，需要使用 `git add` 将更改标记为已解决，然后使用 `git rebase --continue` 继续 rebase 过程。如果想要取消 rebase，可以使用 `git rebase --abort`。\n\n### 提交历史\n\n使用 `git pull --rebase` 可以保持提交历史的线性，但也会改变本地提交的 SHA-1 值。因此，如果你已经将本地分支推送到远程仓库，使用 `git pull --rebase` 可能会导致冲突或其他问题。在这种情况下，建议谨慎操作或与团队成员协商后再进行 rebase。','\n',char(10)));
INSERT INTO commands VALUES(45,'列出当前配置的远程仓库','更新与发布','git remote -v','`git remote -v` 命令用于列出当前 Git 仓库中配置的所有远程仓库及其对应的 URL。该命令可以帮助开发者快速查看本地仓库与远程仓库的关联情况。',replace('# 列出当前配置的远程仓库\n\n## 一、命令介绍\n\n`git remote -v` 命令用于列出当前 Git 仓库中配置的所有远程仓库及其对应的 URL。该命令可以帮助开发者快速查看本地仓库与远程仓库的关联情况。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit remote -v\n```\n\n### 命令示例\n\n```bash\ngit remote -v\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的远程仓库信息及对应解释：\n\n```bash\n# 输出示例\norigin  https://github.com/user/repo.git (fetch)\norigin  https://github.com/user/repo.git (push)\n```\n\n- `origin`: 远程仓库的名称，通常是默认的名称。\n- `https://github.com/user/repo.git`: 远程仓库的 URL。\n- `(fetch)`: 表示该 URL 用于从远程仓库拉取（fetch）数据。\n- `(push)`: 表示该 URL 用于向远程仓库推送（push）数据。\n\n## 四、注意事项\n\n### 远程仓库名称\n\n默认情况下，远程仓库的名称是 `origin`，但可以根据需要修改或添加其他名称。\n\n### 多远程仓库\n\n一个本地 Git 仓库可以配置多个远程仓库，`git remote -v` 将列出所有配置的远程仓库及其 URL。','\n',char(10)));
INSERT INTO commands VALUES(46,'删除远程','更新与发布','git remote rm <remote>','`git remote rm` 命令用于从本地仓库中删除指定的远程仓库引用。执行该命令后，本地仓库将不再跟踪指定的远程仓库。',replace('# 删除远程\n\n## 一、命令介绍\n\n`git remote rm` 命令用于从本地仓库中删除指定的远程仓库引用。执行该命令后，本地仓库将不再跟踪指定的远程仓库。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit remote rm <remote>\n```\n\n其中，`<remote>` 是需要删除的远程仓库的名称。\n\n### 命令示例\n\n```bash\ngit remote rm origin\n```\n\n该示例将删除名为 `origin` 的远程仓库引用。\n\n## 三、注意事项\n\n### 1. 不会删除远程仓库\n\n`git remote rm` 命令仅从本地仓库中删除远程仓库的引用，并不会实际删除远程服务器上的仓库。如果需要删除远程服务器上的仓库，需要使用其他工具或方法。\n\n### 2. 确认远程仓库名称\n\n在执行删除操作前，请确保输入的远程仓库名称正确，以免误删。可以通过 `git remote -v` 命令查看当前配置的远程仓库列表及其 URL。\n\n### 3. 影响本地操作\n\n删除远程仓库引用后，与该远程仓库相关的操作（如 `git push`、`git fetch` 等）将无法执行，除非重新添加该远程仓库引用。','\n',char(10)));
INSERT INTO commands VALUES(47,'删除远程分支','更新与发布','git push <remote> :<branch>','`git push` 命令用于将本地的提交推送到远程仓库。通过特定的语法，可以删除远程仓库中的分支。',replace('# 删除远程分支\n\n## 一、命令介绍\n\n`git push` 命令用于将本地的提交推送到远程仓库。通过特定的语法，可以删除远程仓库中的分支。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit push <remote> :<branch>\n```\n\n或\n\n```bash\ngit push <remote> --delete <branch>\n```\n\n### 命令示例\n\n```bash\ngit push origin :feature-branch\n```\n\n或\n\n```bash\ngit push origin --delete feature-branch\n```\n\n## 三、输出说明(视情况修改省略)\n\n执行该命令后，通常会输出类似以下的信息，表示删除远程分支的操作已完成：\n\n```bash\nTo https://github.com/username/repo.git\n - [deleted]         feature-branch\n```\n\n## 四、注意事项\n\n### 确认分支名称\n\n在删除远程分支之前，请确保分支名称正确，以避免误删重要的分支。\n\n### 权限问题\n\n删除远程分支需要相应的权限。如果没有权限，操作将会失败。请确保你有足够的权限来执行此操作。\n\n### 本地分支的同步\n\n删除远程分支后，建议在本地也删除对应的分支，以保持本地仓库的整洁。可以使用以下命令删除本地分支：\n\n```bash\ngit branch -d feature-branch\n```','\n',char(10)));
INSERT INTO commands VALUES(48,'发布标签','更新与发布','git push --tags','`git push --tags` 命令用于将本地仓库中的所有标签推送到远程仓库。通常在本地创建了新的标签后，使用该命令将标签同步到远程仓库，以便团队成员或其他协作者能够共享这些标签。',replace('# 发布标签\n\n## 一、命令介绍\n\n`git push --tags` 命令用于将本地仓库中的所有标签推送到远程仓库。通常在本地创建了新的标签后，使用该命令将标签同步到远程仓库，以便团队成员或其他协作者能够共享这些标签。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit push --tags\n```\n\n### 命令示例\n\n```bash\ngit push --tags\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的信息及对应解释：\n\n```bash\n# 成功的输出示例\nTo https://github.com/username/repository.git\n * [new tag]         v1.0.0 -> v1.0.0\n * [new tag]         v1.1.0 -> v1.1.0\n```\n\n- `* [new tag] v1.0.0 -> v1.0.0` 表示标签 `v1.0.0` 已被成功推送到远程仓库。\n\n## 四、注意事项\n\n### 1. 推送所有标签\n\n`git push --tags` 会推送本地所有的标签到远程仓库，包括新创建的标签和已经存在的标签。请确保你确实需要推送所有标签。\n\n### 2. 选择性推送标签\n\n如果你只想推送特定的标签，可以使用以下命令：\n\n```bash\ngit push origin <tag_name>\n```\n\n其中 `<tag_name>` 是你想要推送的标签名称。\n\n### 3. 删除远程标签\n\n如果你需要删除远程仓库中的标签，可以使用以下命令：\n\n```bash\ngit push --delete origin <tag_name>\n```\n\n其中 `<tag_name>` 是你想要删除的标签名称。','\n',char(10)));
INSERT INTO commands VALUES(49,'合并到本地仓库中','更新与发布','git pull <remote> <branch>','`git pull` 命令用于从远程仓库获取更新并合并到当前分支。它实际上是 `git fetch` 和 `git merge` 两个命令的组合。',replace('# 合并到本地仓库中\n\n## 一、命令介绍\n\n`git pull` 命令用于从远程仓库获取更新并合并到当前分支。它实际上是 `git fetch` 和 `git merge` 两个命令的组合。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit pull <remote> <branch>\n```\n\n- `<remote>`：远程仓库的名称，通常为 `origin`。\n- `<branch>`：要合并的远程分支名称。\n\n### 命令示例\n\n```bash\ngit pull origin master\n```\n\n## 三、输出说明\n\n执行该命令后，Git 会输出以下信息：\n\n```bash\nremote: Counting objects: 3, done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 1), reused 0 (delta 0)\nUnpacking objects: 100% (3/3), done.\nFrom https://github.com/user/repo\n * branch            master     -> FETCH_HEAD\nUpdating e1e2e3e..f1f2f3f\nFast-forward\n file.txt | 2 ++\n 1 file changed, 2 insertions(+)\n```\n\n- `remote: Counting objects`：表示 Git 正在计算远程仓库中的对象数量。\n- `remote: Compressing objects`：表示 Git 正在压缩这些对象。\n- `remote: Total`：表示总共获取的对象数量。\n- `From https://github.com/user/repo`：表示从哪个远程仓库获取更新。\n- `* branch master -> FETCH_HEAD`：表示从远程仓库的 `master` 分支获取更新。\n- `Updating e1e2e3e..f1f2f3f`：表示本地分支的更新范围。\n- `Fast-forward`：表示这是一个快速合并（即没有冲突）。\n- `file.txt | 2 ++`：表示 `file.txt` 文件有两行新增内容。\n\n## 四、注意事项\n\n### 冲突处理\n\n如果远程分支和本地分支有冲突，Git 会提示你手动解决冲突。你需要编辑冲突文件，然后使用 `git add` 命令标记冲突已解决，最后使用 `git commit` 完成合并。\n\n### 确认远程仓库和分支\n\n在执行 `git pull` 命令前，确保你指定的远程仓库和分支名称正确，以免误操作。','\n',char(10)));
INSERT INTO commands VALUES(50,'将本地修改发布到远程仓库','更新与发布','git push <remote> <branch>','`git push` 命令用于将本地仓库的提交推送到远程仓库。它可以将本地的分支更新同步到远程服务器上，从而实现代码的共享和协作。',replace('# 将本地修改发布到远程仓库\n\n## 一、命令介绍\n\n`git push` 命令用于将本地仓库的提交推送到远程仓库。它可以将本地的分支更新同步到远程服务器上，从而实现代码的共享和协作。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit push <remote> <branch>\n```\n\n- `<remote>`：远程仓库的名称，通常为 `origin`。\n- `<branch>`：要推送的本地分支名称。\n\n### 命令示例\n\n```bash\ngit push origin main\n```\n\n以上命令将本地 `main` 分支的修改推送到名为 `origin` 的远程仓库。\n\n## 三、输出说明\n\n执行 `git push` 命令后，Git 会输出推送的进度和结果。以下是一个可能的输出示例：\n\n```bash\nCounting objects: 5, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (5/5), 1.01 KiB | 1.01 MiB/s, done.\nTotal 5 (delta 1), reused 0 (delta 0)\nTo https://github.com/user/repo.git\n   abc1234..def5678  main -> main\n```\n\n## 四、注意事项\n\n### 推送失败的处理\n\n如果远程仓库有其他人提交了更新，可能会导致推送失败。此时需要先执行 `git pull` 拉取远程更新，解决冲突后再推送。\n\n### 强制推送\n\n在某些情况下，可能需要强制推送本地修改到远程仓库，可以使用 `--force` 选项：\n\n```bash\ngit push --force origin main\n```\n\n强制推送会覆盖远程仓库的历史记录，应谨慎使用。','\n',char(10)));
INSERT INTO commands VALUES(51,'显示远程仓库的信息','更新与发布','git remote show <remote>','`git remote show` 命令用于显示指定远程仓库的详细信息，包括远程仓库的URL、跟踪分支的状态、远程分支的更新情况等。',replace('# 显示远程仓库的信息\n\n## 一、命令介绍\n\n`git remote show` 命令用于显示指定远程仓库的详细信息，包括远程仓库的URL、跟踪分支的状态、远程分支的更新情况等。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit remote show <remote>\n```\n\n### 命令示例\n\n```bash\ngit remote show origin\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的信息及对应解释：\n\n```bash\n* remote origin\n  Fetch URL: https://github.com/user/repo.git\n  Push  URL: https://github.com/user/repo.git\n  HEAD branch: main\n  Remote branches:\n    main   tracked\n    dev    tracked\n  Local branches configured for ''git pull'':\n    main   merges with remote main\n    dev    merges with remote dev\n  Local refs configured for ''git push'':\n    main   pushes to main   (up to date)\n    dev    pushes to dev    (up to date)\n```\n\n- `remote origin`：显示远程仓库的名称。\n- `Fetch URL`：远程仓库的获取URL。\n- `Push URL`：远程仓库的推送URL。\n- `HEAD branch`：远程仓库的默认分支。\n- `Remote branches`：远程仓库的分支及其状态。\n- `Local branches configured for ''git pull''`：本地分支与远程分支的拉取配置。\n- `Local refs configured for ''git push''`：本地分支与远程分支的推送配置。\n\n## 四、注意事项\n\n### 远程仓库名称\n\n确保指定的 `<remote>` 名称是正确的，通常默认的远程仓库名称为 `origin`。\n\n### 远程仓库权限\n\n执行该命令需要具有访问远程仓库的权限，否则可能会提示认证失败或无法访问的错误信息。','\n',char(10)));
INSERT INTO commands VALUES(52,'添加新的远程仓库并命名','更新与发布','git remote add <remote> <url>','`git remote add` 命令用于在本地 Git 仓库中添加一个新的远程仓库，并为其指定一个名称。通过该命令，可以将本地仓库与远程仓库关联起来，以便进行代码的推送、拉取等操作。',replace('# 添加新的远程仓库并命名\n\n## 一、命令介绍\n\n`git remote add` 命令用于在本地 Git 仓库中添加一个新的远程仓库，并为其指定一个名称。通过该命令，可以将本地仓库与远程仓库关联起来，以便进行代码的推送、拉取等操作。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit remote add <remote> <url>\n```\n\n### 命令示例\n\n```bash\ngit remote add origin https://github.com/user/repo.git\n```\n\n## 三、输出说明\n\n执行该命令后，通常不会有任何输出。如果命令执行成功，新的远程仓库将被添加到本地 Git 仓库的配置中。可以使用 `git remote -v` 命令查看已配置的远程仓库列表。\n\n```bash\n$ git remote -v\norigin  https://github.com/user/repo.git (fetch)\norigin  https://github.com/user/repo.git (push)\n```\n\n## 四、注意事项\n\n### 远程名称唯一性\n\n`<remote>` 参数指定了远程仓库的名称，该名称在本地仓库中必须是唯一的。如果指定的名称已存在，命令将失败。\n\n### URL 有效性\n\n`<url>` 参数应为有效的远程仓库 URL。通常，这是一个 HTTPS 或 SSH 地址。确保提供的 URL 可以正确访问远程仓库。\n\n### 多次添加同一个远程仓库\n\n如果尝试多次添加同一个远程仓库（相同的 URL 和名称），Git 会忽略后续的添加操作。如果需要更新远程仓库的 URL，可以先使用 `git remote remove` 删除旧的远程仓库，然后再重新添加。','\n',char(10)));
INSERT INTO commands VALUES(53,'重命名远程仓库','更新与发布','git remote rename <remote> <new_remote>','`git remote rename` 命令用于重命名 Git 仓库中的远程仓库的名称。通过该命令，可以将现有的远程仓库名称更改为新的名称。',replace('# 重命名远程仓库\n\n## 一、命令介绍\n\n`git remote rename` 命令用于重命名 Git 仓库中的远程仓库的名称。通过该命令，可以将现有的远程仓库名称更改为新的名称。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit remote rename <remote> <new_remote>\n```\n\n### 命令示例\n\n假设当前 Git 仓库中有一个名为 `origin` 的远程仓库，我们希望将其重命名为 `upstream`，可以使用以下命令：\n\n```bash\ngit remote rename origin upstream\n```\n\n## 三、输出说明\n\n执行该命令后，通常不会有额外的输出信息。如果命令执行成功，远程仓库的名称将从 `<remote>` 更改为 `<new_remote>`。\n\n## 四、注意事项\n\n### 远程仓库必须存在\n\n在使用 `git remote rename` 命令时，指定的 `<remote>` 必须是一个已经存在的远程仓库名称。如果指定的远程仓库不存在，命令将无法执行。\n\n### 新名称不能与现有仓库冲突\n\n`<new_remote>` 必须是尚未被其他远程仓库使用的名称。如果新名称与现有的远程仓库名称冲突，命令将无法执行。','\n',char(10)));
INSERT INTO commands VALUES(54,'修改上次提交','本地修改','git commit --amend','`git commit --amend` 命令用于修改最近一次提交。它可以用来更正提交信息、添加遗漏的文件或将新的更改包含在上次提交中。',replace('# 修改上次提交\n\n## 一、命令介绍\n\n`git commit --amend` 命令用于修改最近一次提交。它可以用来更正提交信息、添加遗漏的文件或将新的更改包含在上次提交中。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit commit --amend\n```\n\n### 命令示例\n\n```bash\ngit commit --amend\n```\n\n## 三、输出说明\n\n执行该命令后，Git 会打开默认的文本编辑器，允许你修改提交信息。如果你没有修改提交信息，Git 会保留原来的提交信息。\n\n## 四、注意事项\n\n### 修改已发布的提交\n\n请勿修改已发布的提交记录！修改已经推送到远程仓库的提交会导致历史记录不一致，可能会给其他协作者带来困扰。\n\n### 添加遗漏的文件\n\n如果你在上次提交中遗漏了某些文件，可以先使用 `git add` 命令将文件添加到暂存区，然后运行 `git commit --amend` 命令将遗漏的文件包含在上次提交中。','\n',char(10)));
INSERT INTO commands VALUES(55,'修改上次提交的 author date','本地修改','git commit --amend --date="date"','`git commit --amend --date="date"` 命令用于修改最近一次提交的 `author date`。`author date` 是提交的作者日期，通常记录提交的创建时间。通过该命令，用户可以手动指定一个新的日期来覆盖之前的 `author date`。',replace('# 修改上次提交的 author date\n\n## 一、命令介绍\n\n`git commit --amend --date="date"` 命令用于修改最近一次提交的 `author date`。`author date` 是提交的作者日期，通常记录提交的创建时间。通过该命令，用户可以手动指定一个新的日期来覆盖之前的 `author date`。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit commit --amend --date="date"\n```\n\n### 命令示例\n\n```bash\ngit commit --amend --date="2023-10-01T12:00:00"\n```\n\n## 三、输出说明\n\n执行该命令后，Git 会打开默认的文本编辑器，允许用户修改提交信息。如果用户不修改提交信息并保存退出，Git 会将最近的提交的 `author date` 更新为指定的日期。通常情况下，不会有额外的输出信息，但提交历史中的日期会被更新。\n\n## 四、注意事项\n\n### 修改日期格式\n\n`date` 参数需要符合 Git 支持的日期格式，通常为 `YYYY-MM-DDTHH:MM:SS` 或者 `YYYY-MM-DD`。如果日期格式不正确，Git 会抛出错误。\n\n### 影响提交历史\n\n使用该命令会修改提交历史中的 `author date`，因此请谨慎使用，特别是在多人协作的项目中，以避免造成不必要的混淆。\n\n### 其他选项\n\n`--amend` 选项不仅可以修改 `author date`，还可以修改提交信息和内容。如果只需要修改日期，而不修改其他内容，只需指定 `--date` 参数即可。','\n',char(10)));
INSERT INTO commands VALUES(56,'修改上次提交的 committer date','本地修改','GIT_COMMITTER_DATE="date" git commit --amend','该命令用于修改最近一次提交的 committer date（提交者日期）。通过设置环境变量 `GIT_COMMITTER_DATE` 并重新提交，可以更改最后一次提交的时间记录。',replace('# 修改上次提交的 committer date\n\n## 一、命令介绍\n\n该命令用于修改最近一次提交的 committer date（提交者日期）。通过设置环境变量 `GIT_COMMITTER_DATE` 并重新提交，可以更改最后一次提交的时间记录。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\nGIT_COMMITTER_DATE="date" git commit --amend\n```\n\n### 命令示例\n\n```bash\nGIT_COMMITTER_DATE="2023-10-01T12:00:00" git commit --amend\n```\n\n## 三、输出说明\n\n执行该命令后，Git 会重新提交最后一次提交，并使用指定的 `GIT_COMMITTER_DATE` 作为新的提交者日期。不会产生额外的输出信息，但可以使用 `git log` 查看提交记录以确认日期是否已更新。\n\n## 四、注意事项\n\n### 日期格式\n\n`GIT_COMMITTER_DATE` 的日期格式应符合 ISO 8601 标准，例如 `YYYY-MM-DDTHH:MM:SS`。\n\n### 提交记录\n\n使用该命令会修改提交记录中的 committer date，但不会更改提交的内容或作者信息。请确保在执行前了解其影响。\n\n### 仓库状态\n\n执行该命令会修改提交历史，因此不推荐在已经推送到远程仓库的提交上使用。如果需要修改远程仓库的提交记录，请谨慎操作并通知团队成员。','\n',char(10)));
INSERT INTO commands VALUES(57,'删除缓存的变化','本地修改','git stash drop [<stash>]','`git stash drop` 命令用于删除 Git 存储（stash）中的最近一次缓存的变化。执行该命令后，指定的缓存将被永久删除，无法恢复。',replace('# 删除缓存的变化\n\n## 一、命令介绍\n\n`git stash drop` 命令用于删除 Git 存储（stash）中的最近一次缓存的变化。执行该命令后，指定的缓存将被永久删除，无法恢复。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit stash drop [<stash>]\n```\n\n### 命令示例\n\n删除最近一次的缓存变化：\n\n```bash\ngit stash drop\n```\n\n删除指定索引的缓存变化（例如索引为 1 的缓存）：\n\n```bash\ngit stash drop stash@{1}\n```\n\n## 三、输出说明\n\n执行该命令后，如果成功删除缓存变化，命令行会显示类似以下信息：\n\n```bash\nDropped stash@{0} (e6d8c7f8a9b1c4d5e6f7a8b9c0d1e2f3a4b5c6d)\n```\n\n其中 `stash@{0}` 是被删除的缓存的索引。\n\n## 四、注意事项\n\n### 删除后无法恢复\n\n删除缓存变化后，这些变化将永久丢失，无法恢复。请在确认不再需要这些缓存后再执行删除操作。\n\n### 确定缓存索引\n\n在执行 `git stash drop` 命令时，请确保指定的缓存索引正确无误，以免误删其他缓存。可以使用 `git stash list` 命令查看所有缓存的索引。','\n',char(10)));
INSERT INTO commands VALUES(58,'将缓存的变化应用到当前分支','本地修改','git stash apply [<stash>]','`git stash apply` 命令用于将之前通过 `git stash` 命令保存的临时更改应用到当前工作目录中。该命令不会从 stash 列表中移除这些更改，因此可以多次应用相同的 stash。',replace('# 将缓存的变化应用到当前分支\n\n## 一、命令介绍\n\n`git stash apply` 命令用于将之前通过 `git stash` 命令保存的临时更改应用到当前工作目录中。该命令不会从 stash 列表中移除这些更改，因此可以多次应用相同的 stash。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit stash apply [<stash>]\n```\n\n- `<stash>`：可选参数，指定要应用的 stash。如果不指定，默认应用最近一次的 stash。\n\n### 命令示例\n\n1. 应用最近一次的 stash：\n   ```bash\n   git stash apply\n   ```\n\n2. 应用指定的 stash（例如 `stash@{1}`）：\n   ```bash\n   git stash apply stash@{1}\n   ```\n\n## 三、输出说明\n\n执行 `git stash apply` 命令后，Git 会将 stash 中的更改应用到当前工作目录。如果存在冲突，Git 会提示你手动解决这些冲突。\n\n```bash\n# 示例输出\nOn branch main\nYour branch is up to date with ''origin/main''.\n\nChanges to be committed:\n  (use "git restore --staged <file>..." to unstage)\n        modified:   README.md\n\nChanges not staged for commit:\n  (use "git add <file>..." to update what will be committed)\n  (use "git restore <file>..." to discard changes in working directory)\n        modified:   index.html\n```\n\n## 四、注意事项\n\n### 冲突解决\n\n在应用 stash 时，如果当前工作目录中的文件与 stash 中的更改存在冲突，Git 会将这些冲突标记出来。你需要手动解决这些冲突，然后使用 `git add` 命令将解决后的文件标记为已解决。\n\n### 多次应用\n\n`git stash apply` 不会从 stash 列表中移除应用的 stash。这意味着你可以多次应用相同的 stash。如果希望应用 stash 后将其移除，可以使用 `git stash pop` 命令。\n\n### 指定 stash\n\n如果你有多个 stash，可以通过指定 stash 标识符来应用特定的 stash。例如，`stash@{1}` 表示第二最近的 stash。','\n',char(10)));
INSERT INTO commands VALUES(59,'把对某个文件的修改添加到下次提交中','本地修改','git add -p <file>','`git add -p` 命令允许用户交互式地选择文件的修改内容，并将其添加到下次提交中。通过该命令，用户可以精细地控制哪些修改需要提交，哪些不需要，适用于需要对文件进行部分提交的场景。',replace('# 把对某个文件的修改添加到下次提交中\n\n## 一、命令介绍\n\n`git add -p` 命令允许用户交互式地选择文件的修改内容，并将其添加到下次提交中。通过该命令，用户可以精细地控制哪些修改需要提交，哪些不需要，适用于需要对文件进行部分提交的场景。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit add -p <file>\n```\n\n### 命令示例\n\n```bash\ngit add -p example.txt\n```\n\n## 三、输出说明\n\n执行该命令后，Git 会逐个显示文件的修改内容，并提示用户选择是否将该部分修改添加到提交中。用户可以通过以下选项进行操作：\n\n```bash\ny - 将当前修改块添加到下次提交\nn - 不将当前修改块添加到下次提交\nq - 退出交互模式，保留未添加的修改\na - 将当前修改块及其后的所有修改块都添加到下次提交\nd - 不将当前修改块及其后的所有修改块添加到下次提交\ns - 将当前修改块拆分成更小的块\n```\n\n## 四、注意事项\n\n### 1. 确认修改内容\n\n在使用 `git add -p` 时，务必仔细确认每个修改块的内容，确保只添加需要的修改，避免误提交不必要的更改。\n\n### 2. 拆分修改块\n\n如果某个修改块包含了多个不相关的修改，可以使用 `s` 选项将其拆分成更小的块，以便更有针对性地进行提交。','\n',char(10)));
INSERT INTO commands VALUES(60,'把当前分支中未提交的修改移动到其他分支','本地修改','git stash','本命令用于将当前分支中未提交的修改暂存起来，并切换到目标分支后将暂存的修改应用到目标分支上。这在你需要临时切换分支但又不想提交当前修改时非常有用。',replace('# 把当前分支中未提交的修改移动到其他分支\n\n## 一、命令介绍\n\n本命令用于将当前分支中未提交的修改暂存起来，并切换到目标分支后将暂存的修改应用到目标分支上。这在你需要临时切换分支但又不想提交当前修改时非常有用。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\n$ git stash\n$ git checkout <目标分支>\n$ git stash pop\n```\n\n### 命令示例\n\n假设你在 `feature-branch` 分支上有一些未提交的修改，现在需要切换到 `main` 分支并将这些修改应用到 `main` 分支上，可以执行以下命令：\n\n```bash\n$ git stash\n$ git checkout main\n$ git stash pop\n```\n\n## 三、输出说明\n\n执行 `git stash` 后，输出可能如下：\n\n```bash\nSaved working directory and index state WIP on feature-branch: 1234567 Commit message\n```\n\n这表示当前未提交的修改已成功暂存。\n\n执行 `git stash pop` 后，输出可能如下：\n\n```bash\nOn branch main\nChanges not staged for commit:\n  (use "git add <file>..." to update what will be committed)\n  (use "git restore <file>..." to discard changes in working directory)\n        modified:   example.txt\n```\n\n这表示暂存的修改已成功应用到当前分支。\n\n## 四、注意事项\n\n### 1. 暂存的修改可能包含冲突\n\n如果在执行 `git stash pop` 时，目标分支上存在与暂存修改冲突的文件，Git 会提示你解决冲突。你需要手动解决冲突后再提交。\n\n### 2. 使用 `git stash apply` 代替 `git stash pop`\n\n如果你不想在应用暂存修改后删除暂存记录，可以使用 `git stash apply` 代替 `git stash pop`。这样你可以多次应用同一个暂存记录。\n\n### 3. 暂存记录的管理\n\n`git stash` 会创建一个暂存记录栈，你可以使用 `git stash list` 查看所有暂存记录，并使用 `git stash drop` 删除特定的暂存记录。','\n',char(10)));
INSERT INTO commands VALUES(61,'把当前所有修改添加到下次提交中','本地修改','git add .','`git add .` 命令用于将当前工作目录中的所有修改（包括新文件、修改的文件和删除的文件）添加到下一次提交中。这是一个常用的命令，用于准备提交前的暂存操作。',replace('# 把当前所有修改添加到下次提交中\n\n## 一、命令介绍\n\n`git add .` 命令用于将当前工作目录中的所有修改（包括新文件、修改的文件和删除的文件）添加到下一次提交中。这是一个常用的命令，用于准备提交前的暂存操作。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit add .\n```\n\n### 命令示例\n\n```bash\n$ git add .\n```\n\n## 三、输出说明\n\n执行该命令后，通常不会有直接的输出信息。如果有新的文件或修改被成功添加到暂存区，Git 不会显示任何提示信息。如果存在未被 Git 跟踪的文件或目录，Git 也不会将其添加到暂存区。\n\n## 四、注意事项\n\n### 1. 慎重使用 `git add .`\n\n`git add .` 会将当前目录下的所有修改添加到暂存区，包括你不希望提交的修改。因此，在使用此命令之前，最好先使用 `git status` 查看当前工作目录的状态，确保你只添加需要提交的修改。\n\n### 2. 忽略文件\n\n如果你不希望某些文件被添加到暂存区，可以将它们添加到 `.gitignore` 文件中。这样，即使这些文件存在于工作目录中，`git add .` 也不会将它们添加到暂存区。\n\n### 3. 特定文件添加\n\n如果你只想添加特定的文件或目录，可以使用 `git add <file>` 或 `git add <directory>` 来代替 `git add .`，这样可以更精确地控制哪些修改被添加到暂存区。','\n',char(10)));
INSERT INTO commands VALUES(62,'把指定文件的修改添加到下次提交中','本地修改','git add <filename1> <filename2> ...','`git add` 命令用于将工作目录中指定文件的修改添加到暂存区，准备进行下一次提交。通过这种方式，你可以选择性地将某些文件的更改包含在下一次提交中，而不是提交所有更改。',replace('# 把指定文件的修改添加到下次提交中\n\n## 一、命令介绍\n\n`git add` 命令用于将工作目录中指定文件的修改添加到暂存区，准备进行下一次提交。通过这种方式，你可以选择性地将某些文件的更改包含在下一次提交中，而不是提交所有更改。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit add <filename1> <filename2> ...\n```\n\n### 命令示例\n\n```bash\ngit add example.txt index.html\n```\n\n## 三、输出说明\n\n执行 `git add` 命令后，不会显示任何输出信息，除非命令执行出错。如果命令成功执行，指定的文件将被添加到暂存区，准备进行下一次提交。\n\n## 四、注意事项\n\n### 文件路径\n\n确保提供的 `<filename>` 是相对于当前工作目录的文件路径。如果文件位于子目录中，需要提供相对路径或绝对路径。\n\n```bash\ngit add src/js/app.js\n```\n\n### 通配符使用\n\n您可以使用通配符 `*` 来添加多个文件。例如，下面的命令会添加所有 `.txt` 文件：\n\n```bash\ngit add *.txt\n```\n\n### 递归添加目录\n\n如果要添加整个目录及其子目录中的所有文件，可以使用 `-A` 选项或者直接指定目录名：\n\n```bash\ngit add .\n```\n\n或者\n\n```bash\ngit add -A\n```\n\n### 撤销添加\n\n如果误将文件添加到暂存区，可以使用 `git reset` 命令将其从暂存区移除：\n\n```bash\ngit reset <filename>\n```\n\n### 忽略 `.gitignore` 文件\n\n`git add` 命令会忽略 `.gitignore` 文件中列出的文件和目录。如果需要添加被忽略的文件，可以使用 `-f` 强制添加：\n\n```bash\ngit add -f <filename>\n```','\n',char(10)));
INSERT INTO commands VALUES(63,'提交之前已标记的变化','本地修改','git commit [选项] [提交消息]','`git commit` 命令用于将暂存区中的更改提交到本地仓库。每次提交都会生成一个唯一的提交记录，包含提交者的信息、提交时间以及提交消息。',replace('# 提交之前已标记的变化\n\n## 一、命令介绍\n\n`git commit` 命令用于将暂存区中的更改提交到本地仓库。每次提交都会生成一个唯一的提交记录，包含提交者的信息、提交时间以及提交消息。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit commit [选项] [提交消息]\n```\n\n### 命令示例\n\n```bash\ngit commit -m "Initial commit with project setup"\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的信息及对应解释：\n\n```bash\n[main (root-commit) abc1234] Initial commit with project setup\n 2 files changed, 10 insertions(+)\n create mode 100644 README.md\n create mode 100644 main.py\n```\n\n- `[main (root-commit) abc1234]`: 表示提交所在的分支（`main`）、是否为初始提交（`root-commit`）以及提交的哈希值（`abc1234`）。\n- `Initial commit with project setup`: 提交消息。\n- `2 files changed, 10 insertions(+)`: 表示有两个文件被修改，共添加了10行内容。\n- `create mode 100644 README.md` 和 `create mode 100644 main.py`: 表示这两个文件被创建并添加到了仓库中。\n\n## 四、注意事项\n\n### 提交消息格式\n\n提交消息应当简洁明了，描述清楚本次提交的内容。通常建议使用以下格式：\n\n```\n<类型>(<范围>): <描述>\n\n<详细说明>\n```\n\n例如：\n\n```\nfeat(api): add user authentication endpoint\n\n- Added POST /auth endpoint\n- Implemented JWT token generation\n```\n\n### 忽略未暂存的更改\n\n`git commit` 只会提交已经被 `git add` 添加到暂存区的更改。如果要跳过暂存步骤并提交所有已跟踪文件的更改，可以使用 `git commit -a` 选项。','\n',char(10)));
INSERT INTO commands VALUES(64,'提交本地的所有修改','本地修改','git commit -a','`git commit -a` 是一个用于提交本地所有修改的命令。该命令会自动将所有已跟踪文件的修改（包括删除和新增）添加到暂存区，并创建一个新的提交。',replace('# 提交本地的所有修改\n\n## 一、命令介绍\n\n`git commit -a` 是一个用于提交本地所有修改的命令。该命令会自动将所有已跟踪文件的修改（包括删除和新增）添加到暂存区，并创建一个新的提交。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit commit -a\n```\n\n### 命令示例\n\n```bash\ngit commit -a -m "提交所有的修改"\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的信息及对应解释：\n\n```bash\n[master 1a2b3c4d] 提交所有的修改\n 2 files changed, 10 insertions(+), 5 deletions(-)\n```\n\n- `[master 1a2b3c4d]`：表示当前所在分支（`master`）以及提交的哈希值（`1a2b3c4d`）。\n- `2 files changed`：表示有 2 个文件被修改。\n- `10 insertions(+), 5 deletions(-)`：表示在文件中增加了 10 行内容，删除了 5 行内容。\n\n## 四、注意事项\n\n### 已跟踪文件\n\n`git commit -a` 只会提交已经被 Git 跟踪的文件。如果是新文件，需要先使用 `git add` 命令将其添加到 Git 的跟踪列表中。\n\n### 提交信息\n\n虽然 `git commit -a` 可以自动提交所有修改，但仍然建议使用 `-m` 参数为提交添加描述信息，以便于后续查看提交历史。','\n',char(10)));
INSERT INTO commands VALUES(65,'提交，并将提交时间设置为之前的某个日期','本地修改','git commit --date="DATE" -am "COMMIT_MESSAGE"','`git commit --date` 命令用于提交更改，并将提交时间设置为指定的日期。这在需要模拟历史提交或其他需要特定时间戳的场景中非常有用。',replace('# 提交，并将提交时间设置为之前的某个日期\n\n## 一、命令介绍\n\n`git commit --date` 命令用于提交更改，并将提交时间设置为指定的日期。这在需要模拟历史提交或其他需要特定时间戳的场景中非常有用。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit commit --date="DATE" -am "COMMIT_MESSAGE"\n```\n\n### 命令示例\n\n假设你想将提交时间设置为 3 天前的日期，可以使用以下命令：\n\n```bash\ngit commit --date="`date --date=''3 day ago''`" -am "Fix bug in authentication module"\n```\n\n## 三、输出说明\n\n执行该命令后，Git 会将更改提交到本地仓库，并使用指定的日期作为提交时间。提交后的输出通常如下：\n\n```bash\n[main 1a2b3c4d] Fix bug in authentication module\n 1 file changed, 5 insertions(+), 3 deletions(-)\n```\n\n## 四、注意事项\n\n### 日期格式\n\n`--date` 参数接受的日期格式可以是任何 `date` 命令能够解析的格式。确保提供的日期格式正确，否则可能会导致提交时间设置失败或不准确。\n\n### 影响提交历史\n\n使用该命令会修改提交时间，因此在共享仓库中使用时要谨慎，以免影响其他人的工作或历史记录的一致性。','\n',char(10)));
INSERT INTO commands VALUES(66,'显示工作路径下已修改的文件','本地修改','git status','`git status` 命令用于显示当前工作目录和暂存区（staging area）的状态。它会列出已修改的文件、未跟踪的文件以及暂存区中准备提交的文件。',replace('# 显示工作路径下已修改的文件\n\n## 一、命令介绍\n\n`git status` 命令用于显示当前工作目录和暂存区（staging area）的状态。它会列出已修改的文件、未跟踪的文件以及暂存区中准备提交的文件。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit status\n```\n\n### 命令示例\n\n```bash\ngit status\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的信息及对应解释：\n\n```bash\n# On branch master\n# Changes not staged for commit:\n#   (use "git add <file>..." to update what will be committed)\n#   (use "git restore <file>..." to discard changes in working directory)\n#\n#       modified:   README.md\n#\n# Untracked files:\n#   (use "git add <file>..." to include in what will be committed)\n#\n#       newfile.txt\n#\n# Changes to be committed:\n#   (use "git restore --staged <file>..." to unstage)\n#\n#       modified:    main.py\n```\n\n- `On branch master`: 表示当前所在的分支是 `master`。\n- `Changes not staged for commit`: 列出已修改但还未暂存的文件。\n- `Untracked files`: 列出未跟踪的文件，即Git尚未开始跟踪的文件。\n- `Changes to be committed`: 列出已暂存并准备提交的文件。\n\n## 四、注意事项\n\n### 1. 查看详细状态\n使用 `git status -s` 或 `git status --short` 可以获取更简洁的状态输出。\n\n```bash\ngit status -s\n```\n\n### 2. 忽略文件\n`.gitignore` 文件中列出的文件不会被显示在未跟踪文件的列表中。','\n',char(10)));
INSERT INTO commands VALUES(67,'显示指定文件的变化','本地修改','git diff <file>','`git diff <file>` 命令用于显示指定文件在工作目录和暂存区之间的差异。它可以帮助你查看文件在最近一次提交之后所做的修改。',replace('# 显示指定文件的变化\n\n## 一、命令介绍\n\n`git diff <file>` 命令用于显示指定文件在工作目录和暂存区之间的差异。它可以帮助你查看文件在最近一次提交之后所做的修改。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit diff <file>\n```\n\n### 命令示例\n\n```bash\ngit diff README.md\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的差异信息及对应解释：\n\n```bash\ndiff --git a/README.md b/README.md\nindex 1234567..89abcde 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,5 +1,5 @@\n # Project Title\n-This is an old description.\n+This is a new description.\n```\n\n- `diff --git a/README.md b/README.md`：显示被比较的文件路径。\n- `index 1234567..89abcde 100644`：显示文件的索引变化。\n- `--- a/README.md` 和 `+++ b/README.md`：分别表示旧文件和新文件的路径。\n- `@@ -1,5 +1,5 @@`：显示文件的变化范围。\n- `-This is an old description.`：删除的行。\n- `+This is a new description.`：新增的行。\n\n## 四、注意事项\n\n### 文件路径\n\n确保指定的文件路径是相对于当前工作目录的路径。如果文件路径错误，命令将无法找到相应的文件。\n\n### 未跟踪的文件\n\n`git diff` 命令只显示已经被Git跟踪的文件的变化。如果文件是未跟踪的，`git diff` 不会显示任何差异。','\n',char(10)));
INSERT INTO commands VALUES(68,'显示提交文件的变化','本地修改','git diff [<options>] [<commit>] [--] [<path>…​]','`git diff` 命令用于显示工作区与暂存区、暂存区与最新提交之间的文件变化。它可以帮助开发者查看文件的修改内容，了解具体的代码更改。',replace('# 显示提交文件的变化\n\n## 一、命令介绍\n\n`git diff` 命令用于显示工作区与暂存区、暂存区与最新提交之间的文件变化。它可以帮助开发者查看文件的修改内容，了解具体的代码更改。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit diff [<options>] [<commit>] [--] [<path>…​]\n```\n\n### 命令示例\n\n1. 比较工作区与暂存区的文件变化：\n   ```bash\n   git diff\n   ```\n\n2. 比较暂存区与最新提交的文件变化：\n   ```bash\n   git diff --cached\n   ```\n\n3. 比较工作区与某次提交的文件变化：\n   ```bash\n   git diff <commit>\n   ```\n\n4. 比较两次提交之间的文件变化：\n   ```bash\n   git diff <commit1> <commit2>\n   ```\n\n5. 比较特定文件的更改：\n   ```bash\n   git diff <file_name>\n   ```\n\n## 三、输出说明\n\n以下是执行 `git diff` 命令后可能输出的信息及对应解释：\n\n```bash\ndiff --git a/file.txt b/file.txt\nindex 1234567..89abcde 100644\n--- a/file.txt\n+++ b/file.txt\n@@ -1,5 +1,5 @@\n-This is the old content.\n+This is the new content.\n```\n\n- `diff --git a/file.txt b/file.txt`：表示文件 `file.txt` 在修改前后的变化。\n- `index 1234567..89abcde 100644`：表示文件的索引信息，1234567 是修改前的索引，89abcde 是修改后的索引。\n- `--- a/file.txt` 和 `+++ b/file.txt`：分别表示修改前后的文件。\n- `@@ -1,5 +1,5 @@`：表示变化的行范围，`-1,5` 表示从第1行开始的5行内容被删除，`+1,5` 表示从第1行开始的5行内容被添加。\n- `-This is the old content.`：表示被删除的行。\n- `+This is the new content.`：表示被添加的行。\n\n## 四、注意事项\n\n### 1. 未跟踪的文件\n`git diff` 不会显示未跟踪的文件（即未通过 `git add` 添加到暂存区的文件）。如果需要查看未跟踪文件的变化，可以使用 `git add` 将其添加到暂存区后再执行 `git diff`。\n\n### 2. 比较特定提交\n在比较特定提交时，可以使用提交的 SHA-1 值或分支名称来指定提交。例如，`git diff HEAD~1 HEAD` 可以比较最新提交与前一次提交的差异。\n\n### 3. 比较特定文件\n如果只想查看特定文件的变化，可以在命令后加上文件路径。例如，`git diff file.txt` 只会显示 `file.txt` 文件的变化。','\n',char(10)));
INSERT INTO commands VALUES(69,'附加消息提交','本地修改','git commit -m ''message here''','`git commit -m` 命令用于提交当前暂存区的内容，并附加一条提交消息。该命令通常用于在本地仓库中记录对文件的修改。',replace('# 附加消息提交\n\n## 一、命令介绍\n\n`git commit -m` 命令用于提交当前暂存区的内容，并附加一条提交消息。该命令通常用于在本地仓库中记录对文件的修改。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit commit -m ''message here''\n```\n\n### 命令示例\n\n```bash\ngit commit -m ''Fix bug in login functionality''\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的信息及对应解释：\n\n```bash\n# On branch main\n# Your branch is ahead of ''origin/main'' by 1 commit.\n#   (use "git push" to publish your local commits)\n#\n# Changes to be committed:\n#       modified:   login.py\n#\n[main 1234567] Fix bug in login functionality\n 1 file changed, 2 insertions(+), 2 deletions(-)\n```\n\n解释：\n- `On branch main`：当前所在的分支是 `main`。\n- `Your branch is ahead of ''origin/main'' by 1 commit.`：本地分支比远程分支 `origin/main` 多了一次提交。\n- `Changes to be committed:`：将要被提交的修改文件列表。\n- `[main 1234567] Fix bug in login functionality`：提交记录，包括提交的哈希值 `1234567` 和提交消息 `Fix bug in login functionality`。\n- `1 file changed, 2 insertions(+), 2 deletions(-)`：本次提交涉及的文件修改统计。\n\n## 四、注意事项\n\n### 提交消息\n\n提交消息应简明扼要，清晰地描述本次提交的内容或目的。良好的提交消息有助于团队协作和代码审查。\n\n### 暂存区\n\n在执行 `git commit -m` 之前，确保所有要提交的更改已经通过 `git add` 命令添加到暂存区。只有暂存区中的更改才会被提交。\n\n### 提交记录\n\n每次提交都会生成一个唯一的哈希值，用于标识该次提交。可以通过 `git log` 查看提交历史记录。','\n',char(10)));
INSERT INTO commands VALUES(70,'列出所有标签','标签管理','git tag [选项]','`git tag` 命令用于列出仓库中的所有标签。标签通常用于标记特定的提交节点，例如发布版本。它可以用来查看当前仓库中的所有标签，或者根据特定模式过滤标签。',replace('# 列出所有标签\n\n## 一、命令介绍\n\n`git tag` 命令用于列出仓库中的所有标签。标签通常用于标记特定的提交节点，例如发布版本。它可以用来查看当前仓库中的所有标签，或者根据特定模式过滤标签。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit tag [选项]\n```\n\n### 命令示例\n\n1. 列出所有标签：\n\n```bash\ngit tag\n```\n\n2. 列出符合特定模式的标签（例如，列出所有以 `v1.` 开头的标签）：\n\n```bash\ngit tag -l "v1.*"\n```\n\n## 三、输出说明\n\n以下是执行 `git tag` 命令后可能输出的示例：\n\n```bash\nv1.0.0\nv1.1.0\nv2.0.0\n```\n\n输出内容为仓库中所有的标签名称，通常按照字母顺序排列。\n\n## 四、注意事项\n\n### 1. 标签的作用范围\n\n标签默认是本地仓库的，如果要将标签推送到远程仓库，需要使用 `git push` 命令。\n\n例如，推送所有标签到远程仓库：\n\n```bash\ngit push --tags\n```\n\n### 2. 标签的分类\n\nGit 中有两种类型的标签：轻量标签（lightweight）和附注标签（annotated）。轻量标签只是一个指向特定提交的引用，而附注标签则包含额外的信息，如标签的创建者、创建时间和消息。\n\n创建附注标签示例：\n\n```bash\ngit tag -a v1.0.0 -m "Release version 1.0.0"\n```\n\n### 3. 删除标签\n\n如果需要删除标签，可以使用 `git tag -d` 命令。\n\n例如，删除本地标签 `v1.0.0`：\n\n```bash\ngit tag -d v1.0.0\n```\n\n删除远程仓库中的标签：\n\n```bash\ngit push origin :refs/tags/v1.0.0\n```\n\n### 4. 过滤标签\n\n可以使用 `-l` 或 `--list` 选项并结合通配符来过滤标签列表。例如，列出所有以 `v1.` 开头的标签：\n\n```bash\ngit tag -l "v1.*"\n```\n','\n',char(10)));
INSERT INTO commands VALUES(71,'列出所有标签及其附加信息','标签管理','git tag -n','`git tag` 命令用于列出、创建、删除或验证标签对象。标签通常用于标记项目历史中的特定点，例如版本发布。使用 `git tag -n` 可以列出所有标签及其附加的注释信息。',replace('# 列出所有标签及其附加信息\n\n## 一、命令介绍\n\n`git tag` 命令用于列出、创建、删除或验证标签对象。标签通常用于标记项目历史中的特定点，例如版本发布。使用 `git tag -n` 可以列出所有标签及其附加的注释信息。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit tag -n\n```\n\n### 命令示例\n\n```bash\ngit tag -n\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的标签及其注释信息：\n\n```bash\nv1.0         Initial release\nv1.1         Fixed critical bugs\nv2.0         Added new features\n```\n\n- 每一行的第一部分是标签名（如 `v1.0`）。\n- 第二部分是标签的注释信息（如 `Initial release`）。\n\n## 四、注意事项\n\n### 标签与分支的区别\n\n标签是静态的，通常用于标记特定的提交点，而分支是动态的，用于开发新功能或修复 bug。在使用标签时，应该明确其用途。\n\n### 标签的命名规范\n\n建议使用语义化的版本号（如 `v1.0.0`）来命名标签，这样可以更清楚地表示版本的变化。\n\n### 标签的注释信息\n\n在创建标签时，可以通过 `-m` 参数添加注释信息，这些信息将在使用 `git tag -n` 命令时显示出来。\n\n```bash\ngit tag -a v1.0 -m "Initial release"\n```\n','\n',char(10)));
INSERT INTO commands VALUES(72,'给当前分支打标签','标签管理','git tag <tag-name>','`git tag` 命令用于在当前分支上创建一个标签。标签通常用于标记项目中的某个重要节点，例如版本发布。标签是静态的，不同于分支，标签不会随着代码的提交而移动。',replace('# 给当前分支打标签\n\n## 一、命令介绍\n\n`git tag` 命令用于在当前分支上创建一个标签。标签通常用于标记项目中的某个重要节点，例如版本发布。标签是静态的，不同于分支，标签不会随着代码的提交而移动。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit tag <tag-name>\n```\n\n- `<tag-name>`: 要创建的标签名称。标签名称通常遵循语义版本控制（例如 `v1.0.0`）。\n\n### 命令示例\n\n假设你想在当前分支上创建一个名为 `v1.0.0` 的标签，你可以使用以下命令：\n\n```bash\ngit tag v1.0.0\n```\n\n## 三、输出说明\n\n执行该命令后，不会输出任何信息。标签成功创建后，你可以使用 `git tag` 命令查看所有标签，或使用 `git show <tag-name>` 查看特定标签的详细信息。\n\n查看所有标签：\n\n```bash\ngit tag\n```\n\n查看特定标签的详细信息：\n\n```bash\ngit show v1.0.0\n```\n\n## 四、注意事项\n\n### 标签名称的命名规范\n\n标签名称应遵循语义版本控制规范或其他项目内部约定，以便更好地管理和理解标签的含义。例如，`v1.0.0` 表示项目的第一个稳定版本。\n\n### 标签的作用范围\n\n标签是基于当前分支的当前提交点创建的。如果你想在某个特定的提交上创建标签，可以先使用 `git checkout <commit-hash>` 切换到该提交，然后创建标签。\n\n### 推送标签到远程仓库\n\n默认情况下，标签只会保存在本地仓库。如果你想将标签推送到远程仓库，可以使用以下命令：\n\n```bash\ngit push origin <tag-name>\n```\n\n或者推送所有标签：\n\n```bash\ngit push origin --tags\n```\n\n### 删除标签\n\n如果你需要删除一个标签，可以使用以下命令：\n\n```bash\ngit tag -d <tag-name>\n```\n\n删除远程仓库中的标签：\n\n```bash\ngit push origin :refs/tags/<tag-name>\n```\n\n### 轻量标签与附注标签\n\n`git tag` 默认创建的是轻量标签（lightweight tag），它只是一个指向特定提交的引用。如果你想创建附注标签（annotated tag），可以使用 `-a` 选项：\n\n```bash\ngit tag -a <tag-name> -m "Tag message"\n```\n','\n',char(10)));
INSERT INTO commands VALUES(73,'给当前分支打标签并打开编辑器附加消息','标签管理','git tag -a <tag-name>','`git tag -a` 命令用于在当前分支上创建一个带注释的标签，并打开默认的文本编辑器以便您为标签附加详细的消息。这个标签会与当前的最新提交相关联，通常用于标记项目的版本发布。',replace('# 给当前分支打标签并打开编辑器附加消息\n\n## 一、命令介绍\n\n`git tag -a` 命令用于在当前分支上创建一个带注释的标签，并打开默认的文本编辑器以便您为标签附加详细的消息。这个标签会与当前的最新提交相关联，通常用于标记项目的版本发布。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit tag -a <tag-name>\n```\n\n### 命令示例\n\n```bash\ngit tag -a v1.0.0\n```\n\n执行该命令后，Git会打开默认的文本编辑器，您可以在编辑器中输入与该标签相关的详细消息。保存并关闭编辑器后，标签即被创建并与当前提交关联。\n\n## 三、输出说明\n\n执行该命令后，通常不会有直接的控制台输出。如果您想查看已创建的标签，可以使用 `git tag` 命令，或者使用 `git show <tag-name>` 查看特定标签的详细信息。\n\n例如：\n\n```bash\ngit tag\n# 输出：\n# v1.0.0\n```\n\n```bash\ngit show v1.0.0\n# 输出：\n# tag v1.0.0\n# Tagger: Your Name <you@example.com>\n# Date:   Mon Oct 10 12:00:00 2022 +0800\n#\n# 版本1.0.0发布\n#\n# commit 1234567890abcdef1234567890abcdef12345678\n# Author: Your Name <you@example.com>\n# Date:   Mon Oct 10 11:59:59 2022 +0800\n#\n#     Initial commit\n```\n\n## 四、注意事项\n\n### 1. 标签名称的选择\n\n标签名称通常遵循语义化版本控制规范（如 `v1.0.0`），以便于管理和识别不同版本的发布。\n\n### 2. 编辑器设置\n\nGit 会根据您的配置使用默认的文本编辑器（如 Vim、Nano 等）。如果您希望更改默认编辑器，可以通过以下命令进行配置：\n\n```bash\ngit config --global core.editor "code --wait"\n```\n\n### 3. 推送标签\n\n默认情况下，`git push` 不会自动推送标签到远程仓库。如果您希望将标签推送到远程仓库，可以使用以下命令：\n\n```bash\ngit push origin <tag-name>\n```\n\n或者推送所有标签：\n\n```bash\ngit push origin --tags\n```\n\n### 4. 删除标签\n\n如果标签创建错误或不再需要，可以通过以下命令删除本地标签：\n\n```bash\ngit tag -d <tag-name>\n```\n\n如果需要删除远程仓库中的标签，可以使用以下命令：\n\n```bash\ngit push origin :refs/tags/<tag-name>\n```','\n',char(10)));
INSERT INTO commands VALUES(74,'给当前分支打标签并附加消息','标签管理','git tag <tag-name> -a -m ''message here''','`git tag` 命令用于在 Git 中创建、列出、删除或验证标签对象（通常是用于标记发布版本）。通过使用 `-a` 选项，可以创建一个带注释的标签，并通过 `-m` 选项附加一条消息。',replace('# 给当前分支打标签并附加消息\n\n## 一、命令介绍\n\n`git tag` 命令用于在 Git 中创建、列出、删除或验证标签对象（通常是用于标记发布版本）。通过使用 `-a` 选项，可以创建一个带注释的标签，并通过 `-m` 选项附加一条消息。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit tag <tag-name> -a -m ''message here''\n```\n\n### 命令示例\n\n```bash\ngit tag v1.0.0 -a -m ''Release version 1.0.0''\n```\n\n## 三、输出说明(视情况修改省略)\n\n执行该命令后，Git 会在当前分支上创建一个带注释的标签，并附加指定的消息。该标签会存储在本地仓库中。\n\n## 四、注意事项\n\n### 标签名称\n\n标签名称应尽量简洁且有意义，通常用于标记重要的版本或里程碑。\n\n### 消息内容\n\n消息内容应清晰描述标签的目的或相关更改的摘要，以便将来查看时能够快速理解。\n\n### 推送标签\n\n创建标签后，默认情况下不会自动推送到远程仓库。如需推送标签，请使用 `git push origin <tag-name>` 或 `git push origin --tags` 推送所有标签。\n\n### 删除标签\n\n如需删除本地标签，可使用 `git tag -d <tag-name>` 命令。如需删除远程标签，可使用 `git push origin --delete <tag-name>` 命令。','\n',char(10)));
INSERT INTO commands VALUES(75,'重命名文件','移动或重命名','git mv <old_file_name> <new_file_name>','`git mv` 命令用于在 Git 仓库中重命名文件或目录。它不仅会修改工作目录中的文件名称，还会将此更改记录到 Git 的历史中，确保 Git 能够正确跟踪文件的移动。',replace('# 重命名文件\n\n## 一、命令介绍\n\n`git mv` 命令用于在 Git 仓库中重命名文件或目录。它不仅会修改工作目录中的文件名称，还会将此更改记录到 Git 的历史中，确保 Git 能够正确跟踪文件的移动。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit mv <old_file_name> <new_file_name>\n```\n\n### 命令示例\n\n```bash\ngit mv old_file.txt new_file.txt\n```\n\n## 三、输出说明\n\n执行该命令后，Git 会显示文件重命名的操作状态。例如：\n\n```bash\nRenaming old_file.txt to new_file.txt\n```\n\n## 四、注意事项\n\n### 文件状态变更\n\n`git mv` 命令会自动将文件的移动操作标记为已暂存，因此在执行该命令后，文件的状态将会变为 "Changes to be committed"。\n\n### 跨目录移动\n\n如果需要将文件移动到不同的目录中，`git mv` 命令同样适用。例如：\n\n```bash\ngit mv file.txt new_directory/file.txt\n```\n\n### Git 历史记录\n\n使用 `git mv` 命令重命名文件后，Git 会保留文件的历史记录，包括在重命名之前的提交记录。这样在查看文件历史时，Git 能够正确处理文件的重命名操作。\n\n### 手动重命名\n\n如果你手动重命名文件（例如使用 `mv` 命令），Git 会将此操作视为删除旧文件并创建新文件。你需要使用 `git add` 和 `git rm` 来手动更新 Git 的跟踪状态。例如：\n\n```bash\nmv old_file.txt new_file.txt\ngit rm old_file.txt\ngit add new_file.txt\n```\n\n### 目录重命名\n\n`git mv` 命令同样适用于重命名目录。例如：\n\n```bash\ngit mv old_directory new_directory\n```\n\n### 强制覆盖\n\n如果目标文件已经存在，`git mv` 命令会报错。如果需要强制覆盖目标文件，可以使用 `-f` 选项：\n\n```bash\ngit mv -f old_file.txt new_file.txt\n```','\n',char(10)));
INSERT INTO commands VALUES(76,'列出 repository 配置','配置','git config --local --list','`git config --local --list` 命令用于列出当前 Git 仓库的本地配置信息。本地配置信息存储在仓库的 `.git/config` 文件中，仅对当前仓库有效。',replace('# 列出 repository 配置\n\n## 一、命令介绍\n\n`git config --local --list` 命令用于列出当前 Git 仓库的本地配置信息。本地配置信息存储在仓库的 `.git/config` 文件中，仅对当前仓库有效。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit config --local --list\n```\n\n### 命令示例\n\n```bash\ngit config --local --list\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的配置信息及对应解释：\n\n```bash\n# 仓库的格式版本，0 表示默认的格式\ncore.repositoryformatversion=0\n# 是否跟踪文件模式，在 Windows 系统中通常设置为 false\ncore.filemode=false\n# 是否为裸仓库，裸仓库没有工作目录，通常用于服务器端\ncore.bare=false\n# 是否记录所有引用的更新，设置为 true 可以方便查看引用的变化\ncore.logallrefupdates=true\n# 是否支持符号链接，设置为 false 表示不支持\ncore.symlinks=false\n# 是否忽略文件名大小写，设置为 true 表示忽略\ncore.ignorecase=true\n# 远程仓库 origin 的 URL 地址\nremote.origin.url=http://192.168.31.93:3003/xxx/xxx.git\n# 从远程仓库 origin 拉取的引用范围\nremote.origin.fetch=+refs/heads/*:refs/remotes/origin/*\n# master 分支对应的远程仓库为 origin\nbranch.master.remote=origin\n# master 分支合并时对应的远程分支\nbranch.master.merge=refs/heads/master\n# VSCode 合并时的基础分支为 origin/master\nbranch.master.vscode-merge-base=origin/master\n```\n\n## 四、注意事项\n\n### 仓库必须已初始化\n\n该命令仅在已经初始化的 Git 仓库中有效。如果当前目录不是一个 Git 仓库，执行该命令将不会输出任何信息。\n\n### 本地配置优先级\n\nGit 配置分为系统级、全局级和本地级，本地配置优先级最高。如果在不同级别配置了相同的变量，本地配置将覆盖全局和系统配置。\n\n### 网络安全\n\n如果远程仓库的 URL 是通过 HTTP 协议访问的，建议使用 HTTPS 协议以提高安全性。\n','\n',char(10)));
INSERT INTO commands VALUES(77,'列出全局配置','配置','git config --global --list','`git config --global --list` 用于列出所有已设置的全局 Git 配置。这些配置通常保存在用户的主目录下的 `.gitconfig` 文件中。',replace('# 列出全局配置\n\n## 一、命令介绍\n\n`git config --global --list` 用于列出所有已设置的全局 Git 配置。这些配置通常保存在用户的主目录下的 `.gitconfig` 文件中。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit config --global --list\n```\n\n### 命令示例\n\n```bash\ngit config --global --list\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的配置信息及对应解释：\n\n```bash\n# 仓库的格式版本，0 表示默认的格式版本\ncore.repositoryformatversion=0\n# 表示是否跟踪文件模式的变化，在 Windows 系统中一般设置为 false，因为 Windows 不支持文件权限的细粒度控制\ncore.filemode=false\n# 表示该仓库是否为裸仓库，裸仓库没有工作目录，通常用于服务器端的仓库，这里设置为 false 表示不是裸仓库\ncore.bare=false\n# 表示是否记录所有引用的更新操作，设置为 true 可以方便查看引用的变化历史\ncore.logallrefupdates=true\n# 表示是否支持符号链接，在某些环境中可能不支持，这里设置为 false 表示不支持\ncore.symlinks=false\n# 表示是否忽略文件名的大小写，设置为 true 时，Git 会忽略文件名大小写的差异\ncore.ignorecase=true\n# 远程仓库 origin 的 URL 地址，这是默认的远程仓库地址\nremote.origin.url=http://192.168.31.93:3003/xxx/xxx.git\n# 从远程仓库 origin 拉取的引用范围，这里表示拉取所有远程分支到本地的对应远程分支\nremote.origin.fetch=+refs/heads/*:refs/remotes/origin/*\n# 表示本地 master 分支对应的远程仓库为 origin\nbranch.master.remote=origin\n# 表示本地 master 分支合并时对应的远程分支\nbranch.master.merge=refs/heads/master\n# 推测为 VSCode 进行合并操作时的基础分支设置\nbranch.master.vscode-merge-base=origin/master\n# 针对 Gitee 仓库的凭证提供者，这里设置为通用的凭证提供者\ncredential.https://gitee.com.provider=generic\n# 提交代码时显示的用户名\nuser.name=xxx\n# 提交代码时显示的用户邮箱\nuser.email=xxx@xxx.com\n# SourceTree 作为差异工具时的命令，这里为空表示未设置\ndifftool.sourcetree.cmd=''''\n# SourceTree 作为合并工具时的命令，这里为空表示未设置\nmergetool.sourcetree.cmd=''''\n# 表示是否信任 SourceTree 合并工具的退出代码\nmergetool.sourcetree.trustexitcode=true\n# Git LFS（Large File Storage）在文件提交时执行的清理操作\nfilter.lfs.clean=git-lfs clean -- %f\n# Git LFS 在文件检出时执行的还原操作\nfilter.lfs.smudge=git-lfs smudge -- %f\n# Git LFS 的过滤器处理程序\nfilter.lfs.process=git-lfs filter-process\n# 表示是否强制要求仓库使用 Git LFS\nfilter.lfs.required=true\n# 针对本地地址 127.0.0.1:3000 的仓库的凭证提供者，设置为通用的凭证提供者\ncredential.http://127.0.0.1:3000.provider=generic\n# 针对本地局域网地址 192.168.31.205:3002 的仓库的凭证提供者，设置为通用的凭证提供者\ncredential.http://192.168.31.205:3002.provider=generic\n# 针对本地局域网地址 192.168.31.93:3003 的仓库的凭证提供者，设置为通用的凭证提供者\ncredential.http://192.168.31.93:3003.provider=generic\n# 表示是否禁用 SSL 验证，设置为 false 表示禁用，存在安全风险，一般不建议在生产环境使用\nhttp.sslverify=false\n# 针对 ghproxy.cn 代理服务的凭证提供者，设置为通用的凭证提供者\ncredential.https://www.ghproxy.cn.provider=generic\n```\n\n## 四、注意事项\n\n### 全局配置与本地配置\n\n全局配置适用于当前用户的所有 Git 仓库，而本地配置仅适用于当前仓库。使用 `git config --list` 可以列出全局和本地的所有配置。\n\n### 修改全局配置\n\n如果需要修改全局配置，可以使用 `git config --global` 命令。例如，设置全局用户名：\n\n```bash\ngit config --global user.name "Your Name"\n```\n\n### SSL 验证\n\nhttp.sslverify=false 会禁用 SSL 验证，这在某些测试环境中可能方便使用，但在生产环境中存在安全风险，因为它可能使数据传输易受中间人攻击。建议在生产环境中保持 SSL 验证开启。\n\n### 配置修改\n\n若要修改全局配置，可使用 git config --global <key> <value> 命令。例如，修改用户名可使用 git config --global user.name "NewName" 。\n','\n',char(10)));
INSERT INTO commands VALUES(78,'列出当前配置','配置','git config --list','`git config --list` 命令用于列出当前 Git 仓库或系统中的所有配置项及其对应的值。通过这些配置项，可以查看与 Git 操作相关的各种设置，例如用户信息、别名、编辑器、远程仓库地址等。',replace('# 列出当前配置\n\n## 一、命令介绍\n\n`git config --list` 命令用于列出当前 Git 仓库或系统中的所有配置项及其对应的值。通过这些配置项，可以查看与 Git 操作相关的各种设置，例如用户信息、别名、编辑器、远程仓库地址等。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit config --list\n```\n\n### 命令示例\n\n```bash\ngit config --list\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的配置信息及对应解释：\n\n```bash\n# 配置使用 astextplain 工具处理文本差异，用于文本格式的文件比较\ndiff.astextplain.textconv=astextplain\n# 配置 Git LFS（Large File Storage）在文件提交时执行的清理操作\nfilter.lfs.clean=git-lfs clean -- %f\n# 配置 Git LFS 在文件检出时执行的还原操作\nfilter.lfs.smudge=git-lfs smudge -- %f\n# 配置 Git LFS 的过滤器处理程序\nfilter.lfs.process=git-lfs filter-process\n# 强制要求仓库使用 Git LFS\nfilter.lfs.required=true\n# 设置 HTTP 协议使用的 SSL 后端为 OpenSSL\nhttp.sslbackend=openssl\n# 指定 SSL 证书文件的路径\nhttp.sslcainfo=C:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt\n# 自动处理换行符，Windows 系统使用 CRLF，其他系统使用 LF\ncore.autocrlf=true\n# 启用文件系统缓存，提高性能\ncore.fscache=true\n# 不支持符号链接\ncore.symlinks=false\n# 拉取代码时不使用变基操作\npull.rebase=false\n# 使用 Windows 凭据管理器来存储和管理 Git 凭证\ncredential.helper=manager\n# 针对 Azure DevOps 仓库，使用 HTTP 路径进行身份验证\ncredential.https://dev.azure.com.usehttppath=true\n# 设置新仓库的默认分支名为 master\ninit.defaultbranch=master\n# 针对 Gitee 仓库，使用通用的凭证提供者\ncredential.https://gitee.com.provider=generic\n# 设置提交代码时显示的用户名\nuser.name=xxx\n# 设置提交代码时显示的用户邮箱\nuser.email=xxx@xx.com\n# 设置 SourceTree 作为差异工具时的命令\ndifftool.sourcetree.cmd=''''\n# 设置 SourceTree 作为合并工具时的命令\nmergetool.sourcetree.cmd=''''\n# 信任 SourceTree 合并工具的退出代码\nmergetool.sourcetree.trustexitcode=true\n# 配置 Git LFS（Large File Storage）在文件提交时执行的清理操作\nfilter.lfs.clean=git-lfs clean -- %f\n# 配置 Git LFS 在文件检出时执行的还原操作\nfilter.lfs.smudge=git-lfs smudge -- %f\n# 配置 Git LFS 的过滤器处理程序\nfilter.lfs.process=git-lfs filter-process\n# 强制要求仓库使用 Git LFS\nfilter.lfs.required=true\n# 针对本地地址 127.0.0.1:3000 的仓库，使用通用的凭证提供者\ncredential.http://127.0.0.1:3000.provider=generic\n# 针对本地局域网地址 192.168.31.205:3002 的仓库，使用通用的凭证提供者\ncredential.http://192.168.31.205:3002.provider=generic\n# 针对本地局域网地址 192.168.31.93:3003 的仓库，使用通用的凭证提供者\ncredential.http://192.168.31.93:3003.provider=generic\n# 禁用 SSL 验证\nhttp.sslverify=false\n# 针对 ghproxy.cn 代理服务，使用通用的凭证提供者\ncredential.https://www.ghproxy.cn.provider=generic\n# 仓库的格式版本\ncore.repositoryformatversion=0\n# 不使用文件模式跟踪（适用于 Windows 系统）\ncore.filemode=false\n# 非裸仓库\ncore.bare=false\n# 记录所有引用的更新\ncore.logallrefupdates=true\n# 不支持符号链接\ncore.symlinks=false\n# 忽略文件名大小写\ncore.ignorecase=true\n# 配置远程仓库 origin 的 URL\nremote.origin.url=http://192.168.31.93:3003/xxx/test.git\n# 配置从远程仓库 origin 拉取的引用范围\nremote.origin.fetch=+refs/heads/*:refs/remotes/origin/*\n# 配置 master 分支的远程仓库为 origin\nbranch.master.remote=origin\n# 配置 master 分支合并的目标引用\nbranch.master.merge=refs/heads/master\n# 配置 VSCode 合并时的基础分支为 origin/master\nbranch.master.vscode-merge-base=origin/master\n```\n\n## 四、注意事项\n\n### 配置项的优先级\n\nGit 配置项可以存储在三个不同的位置：系统级别（`/etc/gitconfig`）、用户级别（`~/.gitconfig`）和仓库级别（`.git/config`）。优先级从高到低依次为仓库级别、用户级别、系统级别。`git config --list` 命令会列出所有级别的配置项，但仓库级别的配置项会覆盖用户级别和系统级别的相同配置项。\n\n### 过滤配置项\n\n如果你只想查看某个特定级别的配置项，可以使用 `--system`、`--global` 或 `--local` 选项来过滤输出。例如，`git config --list --local` 只会列出当前仓库的配置项。\n\n### 修改配置项\n\n要修改配置项，可以使用 `git config` 命令的 `--add`、`--set` 或 `--unset` 选项。例如，`git config --global user.name "Jane Doe"` 会将全局的用户名设置为 `Jane Doe`。\n\n### 安全性\n\n在公开环境中展示配置信息时，需要注意敏感信息（如用户名、邮箱、证书路径等）的保护。\n\n### SSL 验证\n\n禁用 SSL 验证（`http.sslverify=false`）会带来安全风险，建议仅在测试环境或者可信任的网络中使用。\n','\n',char(10)));
INSERT INTO commands VALUES(79,'列出系统配置','配置','git config --system --list','`git config --system --list` 命令用于列出系统中所有 Git 的全局配置项。这些配置项通常存储在系统的 Git 配置文件中，对所有用户和所有仓库生效。',replace('# 列出系统配置\n\n## 一、命令介绍\n\n`git config --system --list` 命令用于列出系统中所有 Git 的全局配置项。这些配置项通常存储在系统的 Git 配置文件中，对所有用户和所有仓库生效。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit config --system --list\n```\n\n### 命令示例\n\n```bash\ngit config --system --list\n```\n\n## 三、输出说明\n\n以下是执行该命令后可能输出的配置信息及对应解释：\n\n```bash\n# 配置使用 astextplain 工具处理文本差异，用于文本格式的文件比较\ndiff.astextplain.textconv=astextplain\n# 配置 Git LFS（Large File Storage）在文件提交时执行的清理操作\nfilter.lfs.clean=git-lfs clean -- %f\n# 配置 Git LFS 在文件检出时执行的还原操作\nfilter.lfs.smudge=git-lfs smudge -- %f\n# 配置 Git LFS 的过滤器处理程序\nfilter.lfs.process=git-lfs filter-process\n# 强制要求仓库使用 Git LFS\nfilter.lfs.required=true\n# 设置 HTTP 协议使用的 SSL 后端为 OpenSSL\nhttp.sslbackend=openssl\n# 指定 SSL 证书文件的路径\nhttp.sslcainfo=C:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt\n# 自动处理换行符，Windows 系统使用 CRLF，其他系统使用 LF\ncore.autocrlf=true\n# 启用文件系统缓存，提高性能\ncore.fscache=true\n# 不支持符号链接\ncore.symlinks=false\n# 拉取代码时不使用变基操作\npull.rebase=false\n# 使用 Windows 凭据管理器来存储和管理 Git 凭证\ncredential.helper=manager\n# 针对 Azure DevOps 仓库，使用 HTTP 路径进行身份验证\ncredential.https://dev.azure.com.usehttppath=true\n# 设置新仓库的默认分支名为 master\ninit.defaultbranch=master\n```\n\n## 四、注意事项\n\n### 权限\n\n执行 `git config --system --list` 命令需要管理员权限，因为系统级的配置文件通常位于系统目录下，普通用户可能没有读取权限。\n\n### 配置文件位置\n\n系统级的 Git 配置文件通常位于 `/etc/gitconfig` 或 `C:\ProgramData\Git\config`。可以通过 `git config --system --list` 查看具体的配置项。\n\n### 配置优先级\n\nGit 配置分为系统级、全局级和仓库级，优先级依次递增。系统级配置是最低优先级的，全局级配置会覆盖系统级配置，而仓库级配置又会覆盖全局级配置。使用 `git config --system --list` 仅查看系统级配置，若要查看全局配置，可使用 `git config --global --list`；若要查看仓库级配置，可使用 `git config --local --list`。\n\n### 敏感信息保护\n\n虽然系统级配置里一般较少包含敏感信息，但仍需留意像证书路径这类信息，在公开环境分享配置时要防止信息泄露。\n\n### SSL 验证\n\n要确保 `http.sslcainfo` 路径指向的证书文件是有效的，这对保障数据传输的安全性至关重要。\n\n### 配置修改\n\n若要修改系统级配置，可使用 `git config --system <key> <value>` 命令。例如，修改新仓库默认分支名可使用 `git config --system init.defaultbranch "new-branch-name"`。不过，修改系统级配置需要管理员权限。\n','\n',char(10)));
INSERT INTO commands VALUES(80,'设置 git 使用的文本编辑器','配置','git config --global core.editor <editor>','`git config --global core.editor` 命令用于设置 Git 使用的文本编辑器。通过该命令，用户可以指定在 Git 操作中需要输入文本时使用的默认编辑器。',replace('# 设置 Git 使用的文本编辑器\n\n## 一、命令介绍\n\n`git config --global core.editor` 命令用于设置 Git 使用的文本编辑器。通过该命令，用户可以指定在 Git 操作中需要输入文本时使用的默认编辑器。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit config --global core.editor <editor>\n```\n\n### 命令示例\n\n```bash\ngit config --global core.editor vi\n```\n\n## 三、输出说明\n\n执行该命令后，Git 会将指定的编辑器设置为全局默认编辑器。该设置会写入用户的全局 Git 配置文件（通常位于 `~/.gitconfig` 文件中），不会在命令行中直接输出任何信息。\n\n## 四、注意事项\n\n### 编辑器路径\n\n确保指定的编辑器在系统的 `PATH` 中可用，否则 Git 将无法找到并启动该编辑器。\n\n### 编辑器兼容性\n\n不同的编辑器可能有不同的命令行参数和启动方式。如果遇到问题，可以查阅编辑器的文档，确保其与 Git 兼容。\n\n### 全局设置\n\n使用 `--global` 选项会将设置应用于当前用户的所有 Git 仓库。如果只想为特定仓库设置编辑器，可以省略 `--global` 选项，并在该仓库的根目录下执行命令。','\n',char(10)));
INSERT INTO commands VALUES(81,'设置 git 命令行输出为彩色','配置','git config --global color.ui auto','`git config --global color.ui auto` 命令用于设置 Git 命令行输出的颜色为自动模式。启用此功能后，Git 会根据不同的操作和状态，自动为命令行输出添加颜色，以提高可读性和用户体验。',replace('# 设置 git 命令行输出为彩色\n\n## 一、命令介绍\n\n`git config --global color.ui auto` 命令用于设置 Git 命令行输出的颜色为自动模式。启用此功能后，Git 会根据不同的操作和状态，自动为命令行输出添加颜色，以提高可读性和用户体验。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit config --global color.ui auto\n```\n\n### 命令示例\n\n```bash\n$ git config --global color.ui auto\n```\n\n## 三、输出说明\n\n执行该命令后，没有直接的输出信息。但后续使用 Git 命令时，命令行输出将会自动应用颜色，例如分支名称、提交信息等会以不同颜色显示。\n\n## 四、注意事项\n\n### 1. 全局配置\n\n`--global` 参数表示该配置将应用于当前用户的所有 Git 仓库。如果只想对当前仓库生效，可以省略 `--global` 参数。\n\n### 2. 取消彩色输出\n\n如果需要取消彩色输出，可以使用以下命令：\n\n```bash\ngit config --global color.ui false\n```\n\n### 3. 颜色自定义\n\n如果需要自定义 Git 输出的颜色，可以通过 `git config` 命令设置具体的颜色选项。例如：\n\n```bash\ngit config --global color.status.added green\n```\n\n该命令会将 `git status` 命令中新增文件的颜色设置为绿色。','\n',char(10)));
INSERT INTO commands VALUES(82,'设置用户名','配置','git config --global user.name "[firstname lastname]"','Git 是一个分布式版本控制系统，它允许开发者在本地和远程仓库之间进行代码的版本管理。为了在提交代码时能够正确标识作者身份，Git 提供了设置用户名的功能。通过 `git config --global user.name` 命令，可以为当前用户全局设置用户名。',replace('# 设置用户名\n\n## 一、命令介绍\n\nGit 是一个分布式版本控制系统，它允许开发者在本地和远程仓库之间进行代码的版本管理。为了在提交代码时能够正确标识作者身份，Git 提供了设置用户名的功能。通过 `git config --global user.name` 命令，可以为当前用户全局设置用户名。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit config --global user.name "[firstname lastname]"\n```\n\n### 命令示例\n\n```bash\ngit config --global user.name "John Doe"\n```\n\n## 三、输出说明\n\n执行该命令后，Git 会将指定的用户名写入全局配置文件（通常位于 `~/.gitconfig` 文件中）。该用户名将用于所有后续的 Git 提交操作。\n\n## 四、注意事项\n\n### 1. 全局配置\n\n使用 `--global` 选项表示该配置将应用于当前用户的全局环境。如果需要对特定仓库进行设置，可以省略 `--global` 选项，并在特定仓库的根目录下执行该命令。\n\n### 2. 用户名格式\n\n用户名应使用引号括起来，特别是在用户名中包含空格时。这确保了 Git 能够正确解析并使用该用户名。\n\n### 3. 检查配置\n\n可以通过以下命令检查当前配置的用户名：\n\n```bash\ngit config --global user.name\n```\n\n这将输出当前设置的全局用户名。','\n',char(10)));
INSERT INTO commands VALUES(83,'设置用户邮箱','配置','git config --global user.email "[valid-email]"','`git config --global user.email` 命令用于设置 Git 的全局用户邮箱。该邮箱信息将会被记录在每次提交的元数据中，便于其他开发者识别提交者的身份。',replace('# 设置用户邮箱\n\n## 一、命令介绍\n\n`git config --global user.email` 命令用于设置 Git 的全局用户邮箱。该邮箱信息将会被记录在每次提交的元数据中，便于其他开发者识别提交者的身份。\n\n## 二、命令使用\n\n### 命令格式\n\n```bash\ngit config --global user.email "[valid-email]"\n```\n\n### 命令示例\n\n```bash\ngit config --global user.email "example@example.com"\n```\n\n## 三、注意事项\n\n### 邮箱格式\n\n请确保提供的邮箱地址是有效的，通常需要符合常见的邮箱格式，例如 `example@example.com`。\n\n### 全局配置\n\n使用 `--global` 选项会将配置应用于当前用户的所有 Git 仓库。如果仅希望为特定仓库设置邮箱，可以省略 `--global` 选项，并在目标仓库目录下执行命令。\n\n### 检查配置\n\n可以使用以下命令检查当前配置的邮箱地址：\n\n```bash\ngit config --global user.email\n```\n\n如果未设置邮箱地址，该命令将返回空的输出。','\n',char(10)));
INSERT INTO commands VALUES(84,'配置文件详解','配置','','',replace('# Git 配置文件详解\n\n## 一、配置文件介绍\n\nGit 使用三种级别的配置文件来管理配置，分别是：\n\n1. 仓库级别（Local）\n2. 用户级别（Global）\n3. 系统级别（System）\n\n## 二、配置文件路径\n\n### 仓库级别配置文件路径 [--local]\n\n```bash\n<repo>/.git/config\n```\n\n### 用户级别配置文件路径 [--global]\n\n```bash\n~/.gitconfig\n```\n\n### 系统级别配置文件路径 [--system]\n\n```bash\n/etc/gitconfig\n```\n\n## 三、配置文件优先级\n\n当存在多个级别的配置时，Git 会按照以下优先级应用配置：\n\n1. 仓库级别（最高优先级）\n2. 用户级别\n3. 系统级别（最低优先级）\n\n## 四、注意事项\n\n### 配置文件格式\n\nGit 配置文件采用 INI 文件格式，使用 `[section]` 来划分不同的配置区域。\n\n### 配置项继承\n\n低优先级的配置会被高优先级的配置覆盖，但未被覆盖的配置项仍然有效。\n\n### 跨平台路径\n\nWindows 系统中，用户级别配置文件路径通常位于：\n\n```bash\nC:\Users\<用户名>\.gitconfig\n```\n','\n',char(10)));
COMMIT;
